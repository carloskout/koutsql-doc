<h1 id="link-top">Introdução</h1>

<p>
    Nesta seção você aprenderá a criar e executar consultas SQL usando DataB.
</p>

<p>
    Se você não viu o módulo
    <a href="/gettingstarted" class="route link-aux" title="Primeiros passos com DataB">
        Como dá os primeiros passos com a library DataB
    </a>,
    volte para lá e veja como configurará-la para poder usá-la.
</p>

<!--Link de navegação de conteudo-->
<h4 class="sub-title">Conteúdo da página</h4>
<div class="note">
    <nav>
        <ul class="pg-sumary">
            <li>
                <a href="#title-01">Consultando Dados</a>
            </li>
            <li>
                <a href="#title-02">Ordenando Dados</a>
            </li>
            <li>
                <a href="#title-03">Filtrando Dados</a>
            </li>
            <li>
                <a href="#title-04">Junção De Tabelas</a>
            </li>
        </ul>
    </nav>
</div>

<h1 class="sub-title" id="title-01"># Consultando Dados</h1>

<p></p>

<p>
    Para fazer consultas SQL use o método <code>select()</code> para especificar a lista de campos que serão
    retornados pela consulta. Você pode passar por parâmetro tanto um array de
    nomes de colunas quanto uma lista de nomes de colunas separadas por virgulas. Em seguida, use o
    método <code>table()</code> para definir em qual tabela será feita a consulta de dados.
</p>

<h5>Usando array como parâmetro:</h5>

<pre>
    <code>
        $columns = array(
            'title',
            'price',
            'published'
        );

        $books = DataB::select($columns)
            ->table('books')
            ->exec()
            ->getAll();

        var_dump($books);
    </code>
</pre>

<h5>Usando lista de campos como parâmetro:</h5>

<pre>
    <code>
        $books = DataB::select('title', 'published')
            ->table('books')
            ->exec()
            ->getAll();

        var_dump($books);
    </code>
</pre>

<p>
    O método <code>exec()</code> é chamado para executar a instrução SQL enquanto o método
    <code>getAll()</code> recupera o resultado retornado pelo o banco de dados.
</p>

<p>Para recuperar todos os campos da tabela use <code>select('*')</code></p>

<h3 class="sub-title">Especificando o método de busca (fetch)</h3>

<p>
    Use <code>getAll()</code> para recuperar todos
    os registros retornados pela consulta:
</p>

<pre>
    <code>
        $authors = DataB::select('*')
            ->table('authors')
            ->exec()
            ->getAll();
            
        var_dump($authors);
    </code>
</pre>

<p>
    O código acima gera a seguinte saída:
</p>

<pre>
    <code>
        array (size=5)
            0 => 
                array (size=2)
                'id' => string '1' (length=1)
                'name' => string 'Yvonne do Amaral Pereira' (length=24)
            1 => 
                array (size=2)
                'id' => string '2' (length=1)
                'name' => string 'Henrik Ibsen' (length=12)
            2 => 
                array (size=2)
                'id' => string '3' (length=1)
                'name' => string 'John Green' (length=10)
            ...
    </code>
</pre>

<p>
    Use <code>getFirst()</code> para recuperar o primeiro
    registro retornado pela consulta:
</p>

<pre>
    <code>
        $category = DataB::select('*')
            ->table('categories')
            ->exec()
            ->getFirst();
            
        var_dump($category);
    </code>
</pre>

<p>
    Use <code>getLast()</code> para recuperar o último
    registro retornado pela consulta:
</p>

<pre>
    <code>
        $author = DataB::select('*')
            ->table('categories')
            ->exec()
            ->getLast();
            
        var_dump($category);
    </code>
</pre>

<p>
    Use <code>getSingleResult()</code> para recuperar o valor literal retornado pela query.
    Observe que, diferente dos outros métodos visto acima, este método não retorna um array contento o resultado da
    consulta: Observe o trecho de código abaixo:
</p>

<pre>
    <code>
        $result = DataB::select(1 + 1)
            ->exec()
            ->getSingleResult();
            
        var_dump($result);

        // A saída do método var_dump() será o valor '2'

    </code>
</pre>

<p>
    Veja este outro exemplo onde buscamos pelo campo <code>title</code> da tabela
    <code>books</code>. Neste exemplo, usamos uma condição para limitar a quantidade de registros retornados pela
    query. Se nenhuma condição for definida, então o método <code>getSingleResult()</code>
    retornará o valor da primeira coluna do primeiro registro encontrado.
</p>

<pre>
    <code>
        $title = DataB::select('title')
            ->table('books')
            ->cond('id')
            ->eq(1)
            ->exec()
            ->getSingleResult();
        
        var_dump($title);
    </code>
</pre>

<p>
    Use <code>getObjects()</code> para recuperar todos os
    registros como objetos. Este método recebe por
    parâmetro o nome da classe que será usada para criar as instâncias dos objetos.
    Se nenhum parâmetro for especificado, então os registros serão retornados como
    objetos 'stdClass':
</p>

<pre>
    <code>

        class Author {

        }
        
        $authors = DataB::select('*')
            ->table('authors')
            ->exec()
            ->getObjects('Author');
        
        var_dump($authors);
    </code>
</pre>

<p>
    O código acima gera a seguinte saída:
</p>

<pre>
    <code>
        array (size=5)
            0 => 
                object(Author)[2]
                public 'id' => string '1' (length=1)
                public 'name' => string 'Yvonne do Amaral Pereira' (length=24)
            1 => 
                object(Author)[6]
                public 'id' => string '2' (length=1)
                public 'name' => string 'Henrik Ibsen' (length=12)
            ...
    </code>
</pre>

<p>
    Use <code>getObject()</code> para recuperar o primeiro
    registro como objeto. Este método recebe como
    parâmetro o nome da classe que será usada para criar a instância do objeto.
    Se nenhum parâmetro for especificado, então o primeiro registro será retornado como
    um objeto 'stdClass'.
</p>

<p>
    Use <code>getLazy()</code> para recuperar o primeiro
    registro como um objeto PDORow onde as variáveis desse objeto correspondem
    aos nomes das colunas da tabela. Esse método faz o carregamento dos
    dados conforme as variáveis do objeto <code>PDORow</code> forem acessadas.
</p>

<h3 class="sub-title">Consultas nativas</h3>

<p>
    Para executar consultas nativas use <code>DataB::nativeSQL()</code>.
    Este método executa qualquer instrução SQL, tanto
    DML quanto DDL.
</p>

<h5>Executando instrução DML</h5>

<pre>
    <code>
        $sql = 'SELECT * FROM authors';
        $authors = DataB::nativeSQL($sql)->getAll();
    </code>
</pre>

<h5>Executando instrução DDL</h5>

<pre>
    <code>
        $sql = 'ALTER TABLE categories ADD COLUMN parent INTEGER';
        $rowCount = DataB::nativeSQL($sql)->rows();
    </code>
</pre>

<h3 class="sub-title">Funções de agregação</h3>

<h5>Buscando o número de registros retornados pela query:</h5>

<pre>
    <code>
        $count = DataB::count('*')
            ->table('categories')
            ->exec()
            ->getSingleResult();
    </code>
</pre>

<h5>Calculando o valor mínimo dentre um conjunto de valores:</h5>

<pre>
    <code>
        $min = DataB::min('price')
        ->table('books')
        ->exec()
        ->getSingleResult();
    </code>
</pre>

<h5>Calculando o valor máximo dentre um conjunto de valores:</h5>

<pre>
    <code>
        $max = DataB::max('price')
        ->table('books')
        ->exec()
        ->getSingleResult();
    </code>
</pre>

<h5>Calculando a média aritmética dentre um conjunto de valores:</h5>

<pre>
    <code>
        $avg = DataB::avg('price')
        ->table('books')
        ->exec()
        ->getSingleResult();
    </code>
</pre>

<h5>Calculando a soma total de todos os valores de um conjunto:</h5>

<pre>
    <code>
        $sum = DataB::sum('price')
        ->table('books')
        ->exec()
        ->getSingleResult();
    </code>
</pre>

<h3 class="sub-title">Executando funções nativas</h3>

<p>
    Use <code>DataB::fn()</code> para executar de forma nativa qualquer função disponível
    no banco de dados. O primeiro parâmetro passado para esse método deve ser o nome da função
    a ser executada, os demais são parâmetros de entradas para a função especificada.
</p>

<h5>Executando função <code>concat</code>:</h5>

<pre>
    <code>
        $result = DataB::fn("concat", "title", "' - Publicado em: '", "published")
            ->table('books')
            ->exec()
            ->getAll();
        
        var_dump($result);
    </code>
</pre>

<p>
    No exemplo acima concatenamos o título e o ano da publicação de todos os
    registros da tabela <code>books</code>. Observe que passamos uma <code>string</code>
    no terceiro parâmetro onde a mesma é passada dentro de aspas simples para que o
    código funcione corretamente. Todo parâmetro que não está dentro de aspas é considerado
    como um campo da tabela especificada na query.
</p>

<pre>
    <code>
        array (size=7)
            0 => 
            array (size=1)
                'concat(title, ' - Publicado em: ', published)' => string 'Memórias de um suicida - Publicado em: 1958' (length=44)
            1 => 
            array (size=1)
                'concat(title, ' - Publicado em: ', published)' => string 'Nas voragens do pecado - Publicado em: 1959' (length=43)
            2 => 
            array (size=1)
                'concat(title, ' - Publicado em: ', published)' => string 'A Doll's House and Other Plays - Publicado em: 1889' (length=51)
        ...
    </code>
</pre>

<h5>Executando função <code>count</code>:</h5>
<pre>
    <code>
        $result = DataB::fn('count', '*')
            ->table('cliente')
            ->exec()
            ->getSingleResult();
    </code>
</pre>

<h1 class="sub-title" id="title-02"># Ordenando Dados</h1>

<p>
    Para ordenar dados use os métodos <code>orderByAsc()</code> e
    <code>orderByDesc()</code>. Esses métodos recebem como parâmetro
    a(s) coluna(s) que serão usadas na ordenação dos dados.
    Observe os exemplos a seguir:
</p>

<h5>Ordenação ascendente.</h5>

<pre>
    <code>
        $books = DataB::select('*')
        ->table('books')
        ->orderByAsc('published')
        ->exec()
        ->getAll();
    </code>
</pre>

<h5>Ordenação descendente.</h5>

<pre>
    <code>
        $books = DataB::select('*')
        ->table('books')
        ->orderByDesc('published')
        ->exec()
        ->getAll();
    </code>
</pre>

<h5>Ordenando colunas.</h5>

<pre>
    <code>
        $books = DataB::select('*')
            ->table('books')
            ->orderByAsc('title', 'published')
            ->exec()
            ->getAll();
    </code>
</pre>

<h1 class="sub-title" id="title-03"># Filtrando Dados</h1>

<h3 class="sub-title">Cláusula where</h3>

<p>
    Use o método <code>cond()</code> para adicionar a cláusula where à
    consulta SQL:
</p>

<pre>
    <code>
        $books = DataB::select('*')
            ->table('books')
            ->cond('price')
            ->eq(29.99)
            ->exec()
            ->getAll();
    </code>
</pre>

<h6>Saída SQL:</h6>

<pre>
    <code>
        SELECT * FROM books WHERE price = ?
    </code>
</pre>

<p>
    Observe a instrução SQL gerada no exemplo acima onde temos o campo
    <code>price = ?</code>. Por padrão, todos os parâmetros de entrada
    para a instrução SQL são convertidos para <strong>mask placeholders</strong> para evitar
    SQL Injection.
</p>

<p>
    Existem duas maneiras para criar parâmetros SQL com dados de entrada usando DataB.
    A primeira é através de métodos que recebem algum valor de entrada, como por exemplo o
    método <code>eq()</code> que equivale ao operador relacional de igualdade. A segunda é
    passando um array de dados para o método <code>exec()</code>. Ao trabalhar desta forma,
    fica ao seu critério usar <strong>mask placeholders</strong> ou <strong>named placeholders</strong>.
    Se você optar por esta, deverá passar um array associativo onde as chaves do array devem
    corresponder aos nomes das colunas da tabela; caso opte por aquela, então você terá que
    passar um array indexado como parâmentro. Veja como funciona:
</p>

<h5>Usando mask placeholders:</h5>

<pre>
    <code>
        $data = array('Romance');

        $category = DataB::select('*')
            ->table('categories')
            ->cond('name')
            ->eq('?')
            ->exec($data)
            ->getAll();
    </code>
</pre>

<h6>Saída SQL:</h6>

<pre>
    <code>
        SELECT * FROM categories WHERE name = ?
    </code>
</pre>

<h5>Usando named placeholders:</h5>

<pre>
    <code>

        $data = array(
            'price' => 29.99,
            'published' => 2011
        );

        $book = DataB::select('*')
            ->table('books')
            ->cond('price')
            ->eq(':price')
            ->and('published')
            ->eq(':published')
            ->exec($data)
            ->getAll();
    </code>
</pre>

<h6>Saída SQL:</h6>

<pre>
    <code>
        SELECT * FROM books WHERE price = :price
            AND published = :published'
    </code>
</pre>

<h3 class="sub-title">Operadores relacionais</h3>

<p>
    Use os seguintes métodos para comparar valores com DataB:
</p>

<ul>
    <li>
        <code>eq()</code> (=)
    </li>
    <li>
        <code>ne()</code> (!=)
    </li>
    <li>
        <code>lt()</code> (&lt;)
    </li>
    <li>
        <code>gt()</code> (&gt;)
    </li>
    <li>
        <code>le()</code> (&lt;=)
    </li>
    <li>
        <code>ge()</code> (&gt;=)
    </li>
</ul>

<p>
    Os métodos de comparação recebem como parâmetro um valor a ser comparado ou uma função
    callback que é usada para criar <a href="#title-">subqueries</a>. Veja um exemplo básico de uso:
</p>

<pre>
    <code>
        $value = 25.00;
        $year = 2005;

        $book = DataB::select('*')
            ->table('books')
            ->cond('price')
            ->gt($value)
            ->or('published')
            ->lt($year)
            ->exec()
            ->getAll();
    </code>
</pre>

<h6>Saída SQL:</h6>

<pre>
    <code>
        SELECT * FROM books WHERE price > ?
                    OR published &lt; ?
    </code>
</pre>

<p>
    Para fazer comparação entre campos de tabelas, use o método <code>DataB::field()</code> para incluir o campo a ser
    comparado na instrução. Observe no trecho de código abaixo onde fazemos um join entre as
    tabelas authors e books. Na cláusula <code>where</code> fazemos a comparação entre o campo <code>id</code>
    da tabela <code>authors</code> e o campo <code>authors_id</code> da tabela <code>books</code>.
</p>

<pre>
    <code>
        $result = DataB::select('authors.name', 'books.title')
            ->table('authors, books')
            ->cond('authors.id')
            ->eq()
            ->field('books.authors_id')
            ->exec()
            ->getAll();
    </code>
</pre>

<h6>Saída SQL:</h6>

<pre>
    <code>
        SELECT authors.name, books.title FROM authors, books 
            WHERE authors.id = books.authors_id
    </code>
</pre>

<h3 class="sub-title">Operadores lógicos</h3>

<h5>Operadores AND e OR</h5>

<p>
    Para combinar duas ou mais expressões lógicas, use os métodos <code>DataB::and()</code> e
    <code>DataB::or()</code>. Esses métodos recebem como parâmetro um nome de um campo
    a ser incluído na expressão ou uma função callback que é usada para criar
    <a href="#title">subexpressões</a>. Observe o trecho de código abaixo:
</p>

<pre>
    <code>
        $books = DataB::select('*')
            ->table('books')
            ->cond('published')
            ->gt(2005)
            ->and('price')
            ->lt(59.99)
            ->exec()
            ->getAll();
    </code>
</pre>

<h5>Operadores IN e NOT IN. </h5>

<p>
    Use os métodos <code>DataB::in()</code> e <code>DataB::notIn()</code>, respectivamente.
    Você pode passar por parâmetro tanto um array de valores quanto um conjunto de valores
    separados por vírgula. Veja como funciona:
</p>

<h6>Passando um conjunto de valores por parâmetro:</h6>

<pre>
    <code>
        $books = DataB::select('*')
            ->table('books')
            ->cond('published')
            ->in(1958, 2011, 2019)
            ->exec()
            ->getAll();
    </code>
</pre>

<h6>Passando um array de valores por parâmetro:</h6>

<pre>
    <code>
        $years = array(1958, 2011, 2019);

        $books = DataB::select('*')
            ->table('books')
            ->cond('published')
            ->notIn($years)
            ->exec()
            ->getAll();
    </code>
</pre>

<h5>Operadores BETWEEN e NOT BETWEEN</h5>

<p>
    Para incluir estes operadores na instrução SQL use os métodos
    <code>DataB::between()</code> e <code>DataB::notBetween()</code>:
</p>

<pre>
    <code>
        $books = DataB::select('*')
            ->table('books')
            ->cond('price')
            ->between(34.59, 48.75)
            ->exec()
            ->getAll();
    </code>
</pre>

<h5>Operador LIKE</h5>

<p>
    DataB disponibiliza três métodos para se trabalhar com o operador <code>LIKE</code>:
</p>

<ul>
    <li>
        <code>DataB::startsWith()</code> - Busca por um valor que começa com um padrão.
    </li>
    <li>
        <code>DataB::contains()</code> - Busca por um valor que contêm um padrão.
    </li>
    <li>
        <code>DataB::endsWith()</code> - Busca por um valor que termina com um padrão.
    </li>
</ul>

<p>
    Esses métodos recebem como parâmetros o padrão a ser usado na busca de valores.
    Observe:
</p>

<pre>
    <code>

        $categories = DataB::select('*')
            ->table('categories')
            ->cond('name')
            ->startsWith('R')
            ->exec()
            ->getAll();
    </code>
</pre>

<p>
    Veja o mesmo exemplo acima só que usando o método <code>DataB::exec()</code> para receber o
    padrão como parâmetro:
</p>

<pre>
    <code>
        $categories = DataB::select('*')
            ->table('categories')
            ->cond('name')
            ->startsWith('?')
            ->exec('R%')
            ->getAll();
    </code>
</pre>

<p>
    No exemplo acima foi usado <code>mask placeholders</code>, mas você pode usar também 
    <code>named placeholders</code>.
</p>

<h5>Operadores IS NULL e IS NOT NULL</h5>

<p>
    Use os métodos <code>DataB::isNull()</code> e <code>DataB::isNotNull()</code>, respectivamente.
    Observe:
</p>

<pre>
    <code>
        $books = DataB::select('*')
            ->table('books')
            ->cond('note')
            ->isNotNull()
            ->exec()
            ->getAll();
    </code>
</pre>

<h3>Restringindo o número de linhas retornados pela consulta</h3>

<p>
    Use <code>DataB::limit()</code>:
</p>

<pre>
    <code>
        $books = DataB::select('*')
            ->table('books')
            ->limit(10)
            ->exec()
            ->getAll();
    </code>
</pre>

<p>
    Você pode especificar também o número de linhas a pular antes de retornar o resultado
    da consulta. Observe:
</p>

<pre>
    <code>
        $books = DataB::select('*')
            ->table('books')
            ->limit(10, 2)
            ->exec()
            ->getAll();
    </code>
</pre>

<h6>Saída SQL</h6>

<pre>
    <code>
        SELECT * FROM produtos LIMIT 2, 10
    </code>
</pre>

<p>
    No trecho de código acima, buscamos por dez registros da tabela <code>produtos</code>, inicando
    na linha seguinte depois da linha <code>2</code>.
</p>

<h3>
    Buscando dados não duplicados
</h3>

<p>Use o método <code>DataB::distinct()</code>:</p>

<pre>
    <code>
        $books = DataB::distinct('published')
            ->table('books')
            ->exec()
            ->getAll();
    </code>
</pre>

<h1 class="sub-title" id="title-04"># Junção de Tabelas</h1>

<p>
    A junção de tabelas com DataB pode ser feita usando um dos seguintes métodos:
    <code>DataB::cond()</code>, <code>DataB::innerJoin()</code>,
    <code>DataB::leftJoin()</code>, <code>DataB::rightJoin()</code> ou
    <code>DataB::crossJoin()</code>.
</p>

<h3 class="sub-title">Junção de tabelas com <code>DataB::cond()</code></h3>

<p>
    No trecho de código abaixo, buscamos por todos os clientes e seus pedidos.
</p>

<pre>
    <code>
        $result = DataB::select('*')
            ->table('clientes cli, pedidos pe')
            ->cond('cli.id')
            ->eq()
            ->field('pe.cliente_id')
            ->exec()
            ->getAll();

        SQL Gerada:
            'select * from clientes cli, pedidos pe 
                where cli.id = pe.cliente_id'
    </code>
</pre>

<h3 class="sub-title">Junção de tabelas com <code>DataB::innerJoin()</code></h3>

<p>
    No exemplo asseguir, buscamos pelo nome de todos os autores e pelos títulos
    de seus respectivos livros:
</p>

<pre>
    <code>
        $result = DataB::select('autores.nome', 'livros.titulo')
            ->table('autores')
            ->innerJoin('livros')
            ->on('autores.id')
            ->eq()
            ->field('livros.autor_id')
            ->exec()
            ->getAll()
        
        SQL Gerada >>>
            'select autores.nome, livros.titulo from autores 
                inner join livros on autores.id = livros.autor_id'
    </code>
</pre>

<p>
    Se os campos de comparação das tabelas envolvidas tiverem o mesmo nome, então você pode usar
    o método <code>DataB::using()</code> em vez do método <code>DataB::on()</code>. Observe:
</p>

<pre>
    <code>
        $result = DataB::select('autores.nome', 'livros.titulo')
            ->table('autores')
            ->innerJoin('livros')
            ->using('autor_id')
            ->exec()
            ->getAll()
        
        SQL Gerada >>>
            'select autores.nome, livros.titulo from autores 
                inner join livros on autores.id = livros.autor_id'
    </code>
</pre>

<p>
    Para que o método <code>DataB::using()</code> funcione corretamente, o nome do campo que
    representa a chave primária na primeira tabela deverá ser idêntico ao campo de referência
    presente na segunda tabela.
</p>