<!doctype html>
<html lang="pt-br">

<head>
  <meta charset="utf-8">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="description" content="O projeto KoutSQL consiste em uma biblioteca PHP que facilita a criação e execução de instruções SQL usando
  PDO (PHP Data Object)">
  <meta name="keywords" content="KoutSQL, Documentacao KoutSQL, PHP MySQL, PHP SQL Server, PHP Data Object PDO">
  <meta name="author" content="Carlos Coutinho">
  <meta name="theme-color" content="#0d6efd">
  <meta name="msapplication-navbutton-collor" content="#0d6efd">
  <meta name="apple-mobile-web-app-status-bar-style" content="#0d6efd">
  <title>Documentação KoutSQL</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.1/font/bootstrap-icons.css">

  <link rel="stylesheet" href="./css/idea.min.css">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="./css/style.css">

  <script src="./js/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>
  <header class="container-fluid bg-primary" id="header-top">
    <div>
      <button class="btn-bar" onclick="toggleSidebar()">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <div><a id="logo" href="#">KoutSQL</a></div>
    <div>
      <a href="https://github.com/carloskout/koutsql" id="link-github" target="_blank">
        KouSQL no Github
        <i class="bi bi-box-arrow-up-right"></i>
      </a>
    </div>
  </header>

  <!--Siderbar-->
  <aside class="sidebar" id="sidebarElem">
    <div class="sidebar-header">
      <h3>Conteúdo</h3>
    </div>
    <hr>
    <nav>
      <ul id="summary">
        <li>
          <details>
            <summary onclick="redirect(this)" data-redir="1">
              <a href="#1">1. Introdução</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#1.1">1.1. Pré-requisitos</a>
              </li>
              <li>
                <a href="#1.2">1.2. Detalhes</a>
              </li>
              <li>
                <a href="#1.3">1.3. Como instalar</a>
              </li>
              <li>
                <a href="#1.4">1.4. Configuração e exemplo de uso</a>
              </li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary onclick="redirect(this)" data-redir="2">
              <a href="#2">2. Consultas SQL</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#2.1">2.1. Recuperando resultado</a>
              </li>
              <li>
                <a href="#2.2">2.2. Consultas nativas</a>
              </li>
              <li>
                <a href="#2.3">2.3. Funções de agregação</a>
              </li>
              <li>
                <a href="#2.5">2.5. Ordenação de dados</a>
              </li>
              <li>
                <details>
                  <summary>
                    <a href="#2.6">2.6. Filtrando dados</a>
                  </summary>
                  <ul class="sublist">
                    <li>
                      <a href="#2.6.1">2.6.1. Operadores relacionais</a>
                    </li>
                    <li>
                      <details>
                        <summary>
                          <a href="#2.6.2">2.6.2. Operadores lógicos</a>
                        </summary>
                        <ul class="sublist">
                          <li>
                            <a href="#2.6.2.1">2.6.2.1. AND e OR</a>
                          </li>
                          <li>
                            <a href="#2.6.2.2">2.6.2.2. IN e NOT IN</a>
                          </li>
                          <li>
                            <a href="#2.6.2.3">2.6.2.3. BETWEEN E NOT BETWEEN</a>
                          </li>
                          <li>
                            <a href="#2.6.2.4">2.6.2.4. LIKE</a>
                          </li>
                          <li>
                            <a href="#2.6.2.5">2.6.2.5. IS NULL e IS NOT NULL</a>
                          </li>
                          <li>
                            <a href="#2.6.2.6">2.6.2.6. EXISTS e NOT EXISTS</a>
                          </li>
                        </ul>
                      </details>
                    </li>
                  </ul>
                </details>
              </li>
              <li>
                <a href="#2.7">2.7. Limitando retorno de linhas</a>
              </li>
              <li>
                <a href="#2.8">2.8. Buscando dados não duplicados</a>
              </li>
              <li>
                <a href="#2.9">2.9. Junção de tabelas</a>
              </li>
              <li>
                <a href="#2.10">2.10. Agrupando dados</a>
              </li>
              <li>
                <a href="#2.11">2.11. Union</a>
              </li>
              <li>
                <a href="#2.12">2.12. Subqueries</a>
              </li>
              <li>
                <a href="#2.13">2.12. Subexpressões</a>
              </li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary onclick="redirect(this)" data-redir="3">
              <a href="#3">3. Modificando dados</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#3.1">3.1. Inserindo registros</a>
              </li>
              <li>
                <a href="#3.2">3.2. Atualizando registros</a>
              </li>
              <li>
                <a href="#3.3">3.3. Removendo registros</a>
              </li>
              <li>
                <a href="#3.4">3.4. Usando transações</a>
              </li>
            </ul>
          </details>
        </li>
      </ul>
    </nav>
    <div id="developer">
      <span>Desenvolvido por Carlos Coutinho</span> <br>
      <span>coutinhoco@outlook.com</span>
    </div>
  </aside>

  <main class="content" id="contentElem">
    <div class="row">
      <div class="col-md-9">

        <section>
          <h1 id="1">Introdução</h1>
          <p>
            O projeto KoutSQL consiste em uma biblioteca PHP que facilita a criação e execução de instruções SQL usando
            PDO (PHP Data Object).
          </p>

          <p>
            <strong>OBSERVAÇÃO:</strong> KoutSQL não é uma ferramenta ORM.
          </p>

          <section>
            <h3 id="1.1">Pré-requisitos</h3>
            <p>
              Para usar KoutSQL é necessário ter conhecimento prévio na linguagem PHP e SQL.
            </p>
          </section>

          <section>
            <h3 id="1.2">Detalhes</h3>
            <p>
              Bancos de dados suportados: <b>MYSQL</b> e <b>SQL Server</b>.<br>
              Versão atual: <b>1.0.0</b>.<br>
              Licença: <b>MIT</b>.
            </p>
          </section>

          <section>
            <h3 id="1.3">Como instalar</h3>
            <p>
              KoutSQL pode ser instalada através do Composer, que é um gerenciador de pacotes
              para a linguagem PHP. Basta executar o seguinte comando:
            </p>

            <pre>
              <code>
                composer require kout/koutsql
              </code>
            </pre>
          </section>

          <section>
            <h3 id="1.4">Configuração</h3>
            <p>
              Antes de comerçar a criar e executar instruções SQL você deve
              informar para KoutSQL uma conexão com Banco de Dados existente:
            </p>
          </section>

          <pre>
            <code>
              $connection = new \PDO('mysql:dbname=db_test;host=localhost', 'root', 'root');
              $st = DB::getStatement($connection);
            </code>
          </pre>
        </section>

        <hr>

        <section>
          <h1 id="2">Consultas SQL</h1>
          <p>
            Consultas SQL são feitas usando o método <code>get()</code> que recebe
            dois parâmetros:
          </p>

          <ul>
            <li>
              <p>Primeiro: Um ou mais nomes de tabelas que queremos consultar dados.</p>
            </li>
            <li>
              <p>
                Segundo: Um ou mais campos de tabela(s) que queremos recuperar.
              </p>
            </li>
          </ul>
          <p>
            No exemplo abaixo passamos um array como parâmetro contendo os nomes das colunas que queremos recuperar no
            resultado da query:
          </p>

          <pre>
            <code>
              $result = $st->get('books', ['title', 'price'])->list();
            </code>
          </pre>

          <p>
            Se não informarmos o segundo parâmetro para o método <code>get()</code>,
            será retornado todas as colunas da tabela especificada no primeiro parâmetro.
          </p>

          <p>
            Neste outro exemplo fazemos consultas em duas tabelas distintas:
          </p>

          <pre>
            <code>
              $result = $st->get(['authors', 'books'])->list();
            </code>
          </pre>

          <p>
            Para obter a instrução SQL correspondente ao código acima basta executar
            o método <code>sql()</code> em vez do método <code>list()</code>.
          </p>

          <section>
            <h3 id="2.1">Recuperando resultado</h3>

            <p>
              Nesta seção demonstramos todos os métodos que são usados para
              recuperar o resultado da consulta.
            </p>

            <ul>
              <li>
                <p>
                  Método <code>list()</code>: Obtém array indexado contendo todos os
                  registro retornados pela query.
                </p>

                <pre>
                  <code>
                    $result = $st->get('authors')->list();
                  </code>
                </pre>

                <p>
                  O código acima gera a seguinte saída:
                </p>

                <pre>
                  <code>
                    array (size=5)
                      0 =>
                      array (size=2)
                      'id' => string '1' (length=1)
                      'name' => string 'Yvonne do Amaral Pereira' (length=24)
                      1 =>
                      array (size=2)
                      'id' => string '2' (length=1)
                      'name' => string 'Henrik Ibsen' (length=12)
                      2 =>
                      array (size=2)
                      'id' => string '3' (length=1)
                      'name' => string 'John Green' (length=10)
                      ...
                  </code>
                </pre>
              </li>

              <li>
                <p>
                  Método <code>first()</code>: Retorna array associativo contendo o primeiro registro
                  retornado pela query.
                </p>
              </li>
              <li>
                <p>Método <code>last()</code>: Retorna array associativo contendo o último registro
                  retornado pela query.
                </p>
              </li>

              <li>
                <p>
                  Método <code>singleResult()</code>: Recupera valor literal retornado pela query.
                  Diferente dos outros métodos listado acima este não retorna um array.
                </p>

                <pre>
                  <code>
                    $result = $st->get('users', ['email'])->filter('id', '=', 1)->singleResult();
                    var_dump($result);

                    // A saída do método var_dump() será o valor 'foobar@KoutSQL.com'
                  </code>
                </pre>
              </li>
              <li>
                <p>
                  Método <code>toObjects()</code>: Busca um conjunto de registros no banco de dados
                  e os retorna como instâncias de objetos da classe passada por parâmetro. Se nenhuma
                  classe for especificada, o resultado será retornado como instâncias 'stdClass';
                </p>
                
                <pre>
                  <code>
                    class Book {}
                    $books = $st->get('books')->toObjects(Book::class);
                  </code>
                </pre>

              </li>
              <li>
                <p>
                  Método <code>toObject()</code>: Retorna o primeiro registro da query como instância de objeto da
                  classe
                  especificada por parâmetro.
                </p>
              </li>
              <li>
                <p>
                  Método <code>lazy()</code>: Retorna o primeiro
                  registro como um objeto <code>PDORow</code> onde as variáveis desse objeto correspondem
                  aos nomes das colunas da tabela. Esse método faz o carregamento dos
                  dados conforme as propriedades do objeto <code>PDORow</code> forem acessadas.
                </p>
              </li>
            </ul>

          </section>

          <section>
            <h3 id="2.2">Executando instruções SQL nativas</h3>
            <p>
              Instrução DML:
            </p>

            <pre>
              <code>
                $authors = $st->nativeSQL('SELECT * FROM authors');
              </code>
            </pre>

            <p>
              Instrução DDL:
            </p>

            <pre>
              <code>
                $rowCount = $st->nativeSQL('ALTER TABLE categories ADD COLUMN parent INT');
              </code>
            </pre>

          </section>

          <section>
            <h3 id="2.3">Executando funções do banco de dados</h3>

            <p>
              Contando quantos registros existem na tabela <code>users</code>:
            </p>

            <pre>
              <code>
                $count = $st->get('users')->count('*')->singleResult();
              </code>
            </pre>

            <p>
              Neste outro exemplo contamos quantos livros foram publicados por
              cada autor:
            </p>

            <pre>
              <code>
                $result = $st->get('books', ['authors.name'])
                  ->count('*')
                  ->innerJoin('authors', 'books.authors_id', 'authors.id')
                  ->groupBy('authors.name')
                  ->list();
              </code>
            </pre>

            <p>Veja como fica a instrução SQL correspondente ao código acima:</p>

            <pre>
              <code>
                SELECT authors.name, COUNT(*) FROM books
                INNER JOIN authors ON books.authors_id = authors.id
                GROUP BY authors.name
              </code>
            </pre>

            <p>As demais funções de agregação implementadas em KoutSQL são listadas abaixo:</p>

            <ul>
              <li>
                <code>min()</code> - Busca pelo menor valor dentre um conjuntos de valores.
              </li>
              <li>
                <code>max()</code> - Busca pelo maior valor dentre um conjuntos de valores.
              </li>
              <li>
                <code>avg()</code> - Busca pela média aritmética dentre um conjuntos de valores.
              </li>
              <li>
                <code>sum()</code> - Busca pela soma total dentre um conjuntos de valores.
              </li>
            </ul>

            <p>
              <strong>Observe</strong>: KoutSQL não implementa todas as funções disponíveis nos bancos de dados
              suportados, contanto, é possível executar qualquer função por meio de chamada ao nome da função como se
              fosse um método implementado. Para que a inclusão da função solicitada seja adicionada
              na query, KoutSQL faz uso do método mágico <code>_call()</code>.
            </p>

            <p>
              Veja no exemplo abaixo onde fazemos chamada à função de banco de dados 
              <code>CONCAT()</code>:
            </p>

            <pre>
              <code>
                $result = $st->get('books')->concat('title', "'| R$ '", 'price')->list();
              </code>
            </pre>

            <p>
              Se a função a ser executada for composta por mais de uma palavra separadas
              pelo caractere <code>underline</code>, então
              você deverá chamar a função removendo o caracter <code>underline</code>
              e juntando as palavras usando o estilo <code>Camel Case</code>. Observe:

            <pre>
              <code>
                $result = $st->get('articles')->dateFormat('created_at', "'%d/%m/%Y'")->list();
              </code>
            </pre>

            <p>
              Veja como fica a instrução SQL correspondente ao código acima:
            </p>

            <pre>
              <code>
                SELECT DATE_FORMAT(updated_at, '%d/%m/%Y') FROM articles
              </code>
            </pre>
          </section>

          <section>
            <h3 id="2.5">Ordenação de dados</h3>

            <p>Ordenação ascendente:</p>

            <pre>
              <code>
                $result = $st->get('authors')->orderByAsc('name')->list();
              </code>
            </pre>

            <p>Ordenação descendente:</p>

            <pre>
              <code>
                $result = $st->get('categories')->orderByDesc('name')->list();
              </code>
            </pre>

            <p>Ordenação por mais de uma coluna:</p>

            <pre>
              <code>
                $result = $st->get('articles')->orderByAsc('title', 'created_at')->list();
              </code>
            </pre>

            <p>Ordenação ascendente e descendente:</p>

            <pre>
              <code>
                $result = $st->get('articles')
                ->orderByAsc('title')
                ->orderByDesc('created_at')
                ->list();
              </code>
            </pre>
          </section>

          <section>
            <h3 id="2.6">Filtrando Dados</h3>

            <p>
              Para adicionar predicados à instrução SQL use o método <code>filter()</code>. Outros métodos podem também ser usados em conjuntos, como por exemplo: <code>eqValue()</code>, <code>in()</code>,
              <code>between()</code> etc.
            </p>

            <p>
              Observe no trecho de código abaixo no qual buscamos por todos os registros da tabela
              <code>books</code> onde o preço tem que ser igual a <code>29.99</code>:
            </p>

            <pre>
              <code>
                // Usando apenas o método filter() para adicionar predicados
                $result = $st->get('books')->filter('price', '=', 29.99)->list();

                // Usando o método filter() em conjunto com o método eqValue()
                // para adicionar predicados
                $result = $st->get('books')->filter('price')->eqValue(29.99)->list();
              </code>
            </pre>

            <p>Abaixo ilustramos a instrução SQL equivalente ao trecho de código acima:</p>

            <pre>
              <code>
                SELECT * FROM books WHERE price = :col_1
              </code>
            </pre>

            <p>
              Por padrão, toda entrada de dados para a instrução SQL é convertida para
              <code>Named Placeholders</code> por motivos de segurança para evitar SQL injection.
              Observe no trecho de código acima onde o valor <code>29.99</code> foi convertido
              para <code>:col_1</code>.
            </p>

            <p>
              Em alguns casos, talvez você queira especificar <code>Named Placeholders</code> como entrada em vez de passar os dados literais. Neste caso é necessário passar
              um array associativo contendo os dados de entrada para a instrução SQL. Observe:
            </p>

            <pre>
              <code>
                $data = array('email' => 'foo@bar.com')
                $result = $st->get('users')->filter('email', '=', ':email')->list($data);
              </code>
            </pre>

            <p>
              O array de dados deverá ser passado como parâmetro para os
              <a href="#2.1">métodos que recuperam o resultado
                da consulta</a>.
            </p>

            <p>
              KoutSQL não trabalha com <code>Mask Placeholders</code>, então para evitar 
              divergências no resultado da query evite usá-lo.
            </p>

            <section>
              <h4 id="2.6.1">Operadores relacionais</h4>

              <p>
                Existem duas maneiras de se trabalhar com operadores relacionais com KoutSQL: A primeira
                é usando o método <code>filter()</code>; e a segunda é usando um dos seguintes métodos
                listados abaixo:
              </p>

              <ul>
                <li>
                  <code>eqValue()</code>, <code>eqColumn()</code> (=)
                </li>
                <li>
                  <code>neValue()</code>, <code>neColumn()</code> (!=)
                </li>
                <li>
                  <code>ltValue()</code>, <code>ltColumn()</code> (&lt;)
                </li>
                <li>
                  <code>gtValue()</code>, <code>gtColumn()</code> (&gt;)
                </li>
                <li>
                  <code>leValue()</code>, <code>leColumn()</code> (&lt;=)
                </li>
                <li>
                  <code>geValue()</code>, <code>geColumn()</code> (&gt;=)
                </li>
              </ul>

              <p>
                Usando <code>filter()</code>:
              </p>

              <pre>
                <code>
                  $result = $st->get('users')->filter('email', '=', 'foo@bar.com')->list();
                </code>
              </pre>

              <p>
                Usando métodos específicos:
              </p>

              <pre>
                <code>
                  $result = $st->get('users')->filter('email')->eqValue('foo@bar.com')->list();
                </code>
              </pre>

            </section>

            <section>
              <h4 id="2.6.2">Operadores lógicos</h4>

              <section>
                <h5 id="2.6.2.1">AND e OR</h5>

                <p>
                  Use os métodos <code>and()</code> e <code>or()</code> para fazer encadeamento de expressões
                  lógicas. Observe:
                </p>

                <pre>
                  <code>
                    $result = $st->get('users')->filter('id', '>', 2)
                      ->and('email', '=', 'foo@bar.com')
                      ->or('email', '=', 'bar@foo.com')
                      ->list();
                  </code>
                </pre>

                <p>
                  No exemplo a seguir criamos a mesma expressão lógica acima só que dessa vez usamos
                  os métodos específicos para fazermos comparações:
                </p>

                <pre>
                  <code>
                    $result = $st->get('users')->filter('id')->gtValue(2)
                      ->and('email')->eqValue('foo@bar.com')
                      ->or('email')->eqValue('bar@foo.com')
                      ->list();
                  </code>
                </pre>

                <p>Abaixo ilustramos a instrução SQL equivalente aos dois exemplos acima:</p>

                <pre>
                  <code>
                    SELECT * FROM users WHERE id > :col_1 AND email = :col_2 OR email = :col_3
                  </code>
                </pre>
              </section>

              <section>
                <h5 id="2.6.2.2">IN e NOT IN</h5>

                <p>
                  Os operadores <code>IN</code> e <code>NOT IN</code> podem ser adicionados à query
                  através do método <code>filter()</code> ou através dos métodos <code>in()</code>
                  e <code>notIn()</code>.
                </p>

                <p>
                  Dentro do método <code>filter()</code> o operador <code>IN</code> corresponde ao sinal
                  <code>' -> '</code>, enquanto o operador <code>NOT IN</code> corresponde ao sinal
                  <code>' !-> '</code>. Veja como funciona:
                </p>

                <pre>
                  <code>
                    // Operador IN ->
                    $result = $st->get('users')->filter('id', '->', array(1, 2, 3, 4))->list();
                  </code>
                </pre>

                <p>
                  No trecho de código abaixo demonstramos o mesmo exemplo acima só que
                  usando o método <code>in()</code>:
                </p>

                <pre>
                  <code>
                    $result = $st->get('users')->filter('id')->in(1, 2, 3, 4)->list();

                    // Podemos também passar um array para o método in()
                    $result = $st->get('users')->filter('id')->in([1, 2, 3, 4])->list();
                  </code>
                </pre>

                <p>Os dois exemplos acima gera a mesma instrução SQL:</p>

                <pre>
                  <code>
                    SELECT * FROM users WHERE id IN (:col_1, :col_2, :col_3, :col_4)
                  </code>
                </pre>

                <p>
                  Lembrando que você pode também usar <code>Named Placeholders</code> tanto no método
                  <code>filter()</code> quanto nos métodos <code>in()</code> e <code>notIn()</code>:
                </p>

                <pre>
                  <code>
                    $result = $st->get('users')->filter('id', '!->', array(':id1', ':id2'))
                      ->list(array('id1' => 1, 'id2' => 2));
                  </code>
                </pre>
              </section>

              <section>
                <h5 id="2.6.2.3">BETWEEN e NOT BETWEEN</h5>

                <p>
                  Os operadores <code>BETWEEN</code> e <code>NOT BETWEEN</code> podem ser adicionados à query
                  através do método <code>filter()</code> ou através dos métodos <code>between()</code>
                  e <code>notBetween()</code>.
                </p>

                <p>
                  Dentro do método <code>filter()</code> o operador <code>BETWEEN</code> corresponde ao sinal
                  <code>' | '</code>, enquanto o operador <code>NOT BETWEEN</code> corresponde ao sinal
                  <code>' ^| '</code>. Veja como funciona:
                </p>

                <pre>
                  <code>
                    // Usando operador BETWEEN |
                    $result = $st->get('articles')
                      ->filter('updated_at', '|', array('2022-01-01', '2022-02-01'))->list();
                  </code>
                </pre>

                <p>
                  No código acima buscamos por todos os registros da tabela <code>articles</code>
                  que foram atualizados entre as datas <code>01/01/2022</code> à <code>01/02/2022</code>.
                </p>

                <p>
                  Agora observe o mesmo exemplo acima só que desta vez usando o método <code>between()</code>:
                </p>

                <pre>
                  <code>
                    $result = $st->get('articles')
                      ->filter('updated_at')->between('2022-01-01', '2022-02-01')->list();

                    // Podemos também passar um array para o método between()
                    $result = $st->get('articles')
                      ->filter('updated_at')->between(['2022-01-01', '2022-02-01'])->list();
                  </code>
                </pre>

                <p>
                  Tanto o método <code>filter()</code> quanto os métodos <code>between()</code> e
                  <code>notBetween()</code> aceitam <code>Named Placeholders</code>.
                </p>

                <pre>
                  <code>
                    // Usando método filter()
                    $result = $st->get('articles')
                      ->filter('updated_at', '|', array(':date1', ':date2'))
                      ->list(array('date1' => '2022-01-01', 'date2' => '2022-02-01'));

                    // Usando método between()
                    $result = $st->get('articles')
                      ->filter('updated_at')->between(':date1', ':date2')
                      ->list(array('date1' => '2022-01-01', 'date2' => '2022-02-01'));
                  </code>
                </pre>
              </section>

              <section>
                <h5 id="2.6.2.4">LIKE</h5>

                <p>
                  Além do método <code>filter()</code>, KoutSQL disponibiliza três métodos para se trabalhar com o operador
                  <code>LIKE</code>:
                </p>

                <ul>
                  <li>
                    <code>startsWith()</code> - Busca por um valor que começa com um padrão.
                  </li>
                  <li>
                    <code>contains()</code> - Busca por um valor que contêm um padrão.
                  </li>
                  <li>
                    <code>endsWith()</code> - Busca por um valor que termina com um padrão.
                  </li>
                </ul>

                <p>
                  Se você decidir usar somente o método <code>filter()</code> para incluír o
                  operador <code>LIKE</code> à instrução SQL, então é necessário usar um dos
                  seguintes caracteres para construir o padrão de busca:
                </p>

                <ul>
                  <li>
                    <code>'^'</code> - Busca por um valor que começa com um padrão.
                  </li>
                  <li>
                    <code>'.'</code> - Busca por um valor que contêm um padrão.
                  </li>
                  <li>
                    <code>'$'</code> - Busca por um valor que termina com um padrão.
                  </li>
                </ul>

                <p>
                  A seguir demonstramos o uso do método <code>filter()</code> para buscar somente
                  os registros da tabela <code>categories</code> onde o nome inicia com a letra <code>R</code>:
                </p>

                <pre>
                  <code>
                    $result = $st->get('categories')->filter('name', '^', 'R')->list();
                  </code>
                </pre>

                <p>
                  Veja o mesmo exemplo acima só que usando o método <code>startsWith()</code>:
                </p>

                <pre>
                  <code>
                    $result = $st->get('categories')->filter('name')->startsWith('R')->list();
                  </code>
                </pre>

                <p>
                  Agora observe no exemplo abaixo como usar <code>Named Placeholders</code> com
                  o operador <code>LIKE</code>:
                </p>

                <pre>
                  <code>
                    // Retorna todas as categorias cujo nome termina com 'de'
                    $result = $st->get('categories')->filter('name', '$', ':pattern')
                      ->list(['pattern' => '%de']);
                  </code>
                </pre>
              </section>

              <section>
                <h5 id="2.6.2.5">IS NULL e IS NOT NULL</h5>

                <pre>
                  <code>
                    //IS NULL
                    $result = $st->get('categories')->filter('parent')->isNull()->list();

                    // IS NOT NULL
                    $result = $st->get('categories')->filter('parent')->isNotNull()->list();
                  </code>
                </pre>
              </section>

              <section>
                <h5 id="2.6.2.6">EXISTS e NOT EXISTS</h5>
                <p>
                  KoutSQL disponibiliza os métodos <code>exists()</code> e <code>notExists()</code>
                  os quais recebem como parâmetro uma função <code>callback</code>
                  na qual montamos a subquery.
                </p>

                <p>
                  No trecho de código abaixo demonstramos como recuperar todos os autores que tenham livros publicados
                  entre os anos de
                  <code>2000</code> e <code>2019</code>.
                </p>

                <pre>
                  <code>
                    $result = $st->get('authors')
                      ->exists(function($query) {
                                $query->get('books')
                                ->filter('published', '|', [2000, 2019])
                                ->and('authors.id', '=', '*books.authors_id');
                              })
                      ->list();
                  </code>
                </pre>

                <p>
                  A instrução SQL correspondente ao exemplo anterior fica da seguinte forma:
                </p>

                <pre>
                  <code>
                    SELECT * FROM authors WHERE
                    EXISTS (SELECT * FROM books WHERE published BETWEEN :col_1 AND :col_2 
                    AND authors.id = books.authors_id)
                  </code>
                </pre>

                <p>
                  <strong>OBSERVAÇÃO:</strong> Ao se comparar duas colunas usando os métodos
                  <code>filter()</code>, <code>and()</code>, <code>or()</code> e <code>subexpr()</code>; a última coluna deverá ser precedida pelo caracter <code>'*'</code>. Isso
                  é necessário para que a ultima coluna não seja interpretada como um valor literal da primeira coluna.
                </p>

                <p>
                  Por exemplo, no trecho de código a seguir fazemos comparação entre duas colunas:
                </p>

                <pre>
                  <code>
                    $result = $st->get(['articles', 'authors'])
                      ->filter('articles.authors_id', '=', '*authors.id')->list();

                    /*Código SQL:
                    SELECT * FROM articles, authors WHERE articles.authors_id = authors.id*/
                  </code>
                </pre>

                <p>
                  Agora neste outro exemplo fazemos comparação entre a coluna e seu respectivo valor:
                </p>

                <pre>
                  <code>
                    $result = $st->get('users')
                      ->filter('email', '=', 'foo@bar.com')->list();

                    /*Código SQL:
                    SELECT * FROM users WHERE email = :col_1*/
                  </code>
                </pre>

              </section>

              <!--fim secao operadores logicos-->
            </section>

            <!--Fim secao filtrando dados-->
          </section>

          <section>
            <h3 id="2.7">Limitando retorno de linhas</h3>

            <p>
              Para este propósito KoutSQL disponibiliza os seguintes métodos:
              <code>offset()</code> e <code>fetch()</code>.
            </p>

            <p>
              Em banco de dados <code>SQL Server</code> é necessário usar a ordenação de dados
              antes de limitar o retorno de linhas. No <code>MYSQL</code> não é preciso.
            </p>

            <p>
              Veja como funciona usando <code>SQL Server</code>:
            </p>

            <pre>
              <code>
                // Recuperando todos os registros a partir da décima linha
                $result = $st->get('articles')->orderByAsc('title')->offset(10)->list();

                // Recuperando os primeiros 10 registros
                $result = $st->get('articles')->orderByAsc('title')->fetch(10)->list();

                // Recuperando os primeiros 20 registros a partir da décima linha
                $result = $st->get('articles')->orderByAsc('title')->offset(10)->fetch(20)->list();
              </code>
            </pre>

            <p>
              Usando <code>MYSQL</code>:
            </p>

            <pre>
              <code>
                /* Por padrão, se não for especificado o fetch, são retornados somente 1000 registros a partir do offset especificado.*/

                // Recuperando 1000 registros a partir da décima linha.
                $result = $st->get('articles')->offset(10)->list();

                // Recuperando os primeiros 10 registros
                $result = $st->get('articles')->fetch(10)->list();

                // Recuperando 20 registros a partir da décima linha.
                $result = $st->get('articles')->offset(10)->fetch(20)->list();
              </code>
            </pre>
          </section>

          <section>
            <h3 id="2.8">Buscando dados não duplicados</h3>

            <p>
              KoutSQL disponibiliza o método <code>distinct()</code> o qual recebe como parâmetro tanto um array quanto um
              conjunto de colunas separadas por vírgulas.
            </p>

            <pre>
              <code>
                $result = $st->get('employees')->distinct('lastname')->list();

                // Usando mais de uma coluna
                $result = $st->get('employees')->distinct('lastname', 'city')->list();
              </code>
            </pre>

          </section>

          <section>
            <h3 id="2.9"> Junção de tabelas</h3>
            <p>
              Nesta seção demonstramos como fazer junção de tabelas com KoutSQL. No exemplo abaixo
              usamos o método <code>filter()</code> para criar a junção entre
              as tabelas <code>authors</code> e <code>books</code>:
            </p>

            <pre>
              <code>
                $result = $st->get(['books', 'authors'])
                  ->filter('books.authors_id', '=', '*authors.id')->list();

                //Outra maneira usando filter
                $result = $st->get(['books', 'authors'])
                  ->filter('books.authors_id')->eqColumn('authors.id')->list();
              </code>
            </pre>

            <p>
              Usando <code>inner join</code>:
            </p>

            <pre>
              <code>
                $result = $st->get('books')
                  ->innerJoin('authors', 'books.authors_id', 'authors.id')->list();
              </code>
            </pre>

            <p>
              Os demais métodos usados para criar junções de tabelas são estes:
              <code>leftJoin()</code>, <code>rightJoin()</code>, <code>crossJoin()</code> e
              <code>fullJoin()</code>.
            </p>
          </section>

          <section>
            <h3 id="2.10">Agrupando dados</h3>

            <p>
              Para agrupar dados use o método <code>groupBy()</code> e para definir condições
              de agrupamento use o método <code>having()</code>.
            </p>

            <p>
              A seguir demonstramos uma query na qual buscamos todos os registros da tabela
              funcionários agrupando por departamentos:
            </p>

            <pre>
              <code>
                $result = $st->get('employees', ['employees.name', 'departaments.name'])
                  ->innerJoin('departaments', 'employees.dep_id', 'departaments.id')
                  ->groupBy('departaments.name')->list();
              </code>
            </pre>

            <p>Instrução SQL:</p>

            <pre>
              <code>
                SELECT employees.name, departaments.name FROM employees
                INNER JOIN departaments ON employees.dep_id = departaments.id
                GROUP BY departaments.name
              </code>
            </pre>

            <p>
              Se você já está familiarizado com o uso do método <code>filter()</code> então não terá
              nenhum problema em usar o método <code>Data::having()</code> pois funciona da mesma maneira.
            </p>
          </section>

          <section>
            <h3 id="2.11">Union</h3>

            <p>
              Para unir dois ou mais conjuntos de resultados KoutSQL disponibiliza os métodos
              <code>union()</code> e <code>unionAll()</code> que recebem como parâmetro uma <code>função callback</code>
              na qual montamos uma <code>subquery</code>. Observe:
            </p>

            <pre>
              <code>
                //Combinando nomes de funcionários e clientes
                $result = $st->get('employees', ['name'])
                  ->union(function($query) {
                            $query->get('customers', ['name']);
                        })
                  ->list();
              </code>
            </pre>
          </section>

          <section>
            <h3 id="2.12">Subqueries</h3>

            <p>
              No ambiente de banco de dados é bastante comum o uso de subqueries para construir
              consultas SQL complexas. Pois bem, KoutSQL fornece
              suporte a subqueries no qual usamos funções callbacks para criá-las. A maioria dos métodos em KoutSQL
              recebem
              função callback como parâmetro tanto para se criar subqueries quanto subexpressões. A seguir
              disponibilizamos
              uma lista completa com todos os método que suportam subqueries:
            </p>

            <ul>
              <li>
                <code>filter()</code>
              </li>
              <li>
                <code>eqValue()</code>
              </li>
              <li>
                <code>neValue()</code>
              </li>
              <li>
                <code>ltValue()</code>
              </li>
              <li>
                <code>gtValue()</code>
              </li>
              <li>
                <code>leValue()</code>
              </li>
              <li>
                <code>geValue()</code>
              </li>
              <li>
                <code>in()</code>
              </li>
              <li>
                <code>notIn()</code>
              </li>
              <li>
                <code>exists()</code>
              </li>
              <li>
                <code>notExists()</code>
              </li>
              <li>
                <code>union()</code>
              </li>
              <li>
                <code>unionAll()</code>
              </li>
              <li>
                <code>put()</code>
              </li>
              <li><code>remove()</code></li>
            </ul>

            <p>
              No exemplo abaixo demonstramos o uso de subquery com o método <code>filter()</code>
              para o operador <code>IN '->'</code>. Buscamos por registros de autores que tenham
              livros cuja categoria seja Drama:
            </p>

            <pre>
              <code>
                $subQ = function($query) {
                  $query->get('books', ['authors.id'])
                  ->innerJoin('authors', 'authors.id', 'books.author_id')
                  ->innerJoin('categories', 'categories.id', 'books.cat_id')
                  ->and('categories.name', '=', 'Drama');
                };

                $result = $st->get('authors')->filter('id', '->', $subQ)->list();
  
                //Você pode também usar o método in()
                //$result = $st->get('authors')->filter('id')->in($subQ)->list();
              </code>
            </pre>

            <p>Instrução SQL:</p>

            <pre>
              <code>
                SELECT * FROM authors WHERE id IN (SELECT authors.id FROM books INNER JOIN authors ON authors.id = books.author_id INNER JOIN categories ON categories.id = books.cat_id 
                AND categories.name = :col_1)
              </code>
            </pre>
          </section>

          <section>
            <h3 id="2.13">Subexpressões</h3>
            <p>
              Subexpressões são criadas passando uma função callback como parâmetro para os métodos
              <code>and()</code> e <code>or()</code>. Dentro da função callback montamos a
              subexpressão usando o método <code>filter()</code> ou o método <code>subexpr()</code>.
            </p>

            <p>
              Na query a seguir buscamos por registros da tabela artigos cujo campo título comece
              com a palavra <code>'Pres'</code> e termina com a palavra <code>'ente'</code> ou
              <code>'idente'</code>.
            </p>

            <pre>
              <code>
                  $expr = function($query) {
                      $query->filter('title')->endsWith('ente')
                      ->or('title')->endsWith('idente');
                  };

                  $result = $st->get('articles')->filter('title')->startsWith('Pres')
                  ->and($expr)->list();
              </code>
            </pre>

            <p>
              Veja como fica a instrução SQL referente ao exemplo anterior:
            </p>

            <pre>
              <code>
                SELECT * FROM articles
                WHERE title LIKE :col_1 
                AND (title LIKE :col_2 OR title LIKE :col_3)
              </code>
            </pre>
          </section>
          <!--Fim secao consultas-->
        </section>

        <section>
          <h1 id="3">Modificando dados</h1>

          <p>
            Nesta seção você aprenderá como inserir, atualizar e remover registros do banco de dados.
          </p>

          <section>
            <h3 id="3.1">Inserindo registros</h3>

            <p>
              Para inserir novos registros em uma tabela é muito fácil, basta passar
              para o método <code>put()</code> o nome da tabela e um array associativo contendo os dados para inserção.
              Observe: as chaves do array devem corresponder ao nomes das colunas da tabela na qual queremos inserir os
              dados.
            </p>

            <p>
              Ao inserir um novo registro, o método <code>put()</code> retorna o último campo identificador
              <code>(id)</code>.
            </p>

            <pre>
              <code>
                $data = [
                  'email' => 'foo@bar.com',
                  'password' => 'foo123'
                ];

                $id = $st->put('users', $data);
              </code>
            </pre>
          </section>

          <section>
            <h3 id="3.2">Atualizando registros</h3>

            <p>
              Para fazer atualizações também usamos o método <code>put()</code>, mas com um
              diferencial: Devemos passar um terceiro parâmetro que corresponde ao um
              <code>filtro</code>.
            </p>

            <p>
              Existem três maneiras de criarmos um filtro; a primeira é usando uma função
              <code>callback</code>; a segunda é passando um array indexado com dois elementos
              onde o primeiro é nome de uma coluna e segundo é o valor dessa coluna a ser comparado;
              a terceira maneira é passando uma string <code>'*'</code> onde todos os registros da tabela são
              atualizados.
            </p>

            <p>
              Observe como funciona:
            </p>

            <pre>
              <code>
                $data = ['email' => 'bar@foo.com'];

                // Criando filtro usando função callback
                $rowCount = $st->put('users', $data, function($f) {
                  $f->filter('id')->eqValue(2);
                });

                // Criando filtro usando array indexado
                $rowCount = $st->put('users', $data, ['id', 2]);

                //Atualizando todos os registros
                $rowCount = $st->put('users', $data, '*');
              </code>
            </pre>
      </div>
      </section>

      <section>
        <h3 id="3.3">Removendo registros</h3>

        <p>
          Para excluir registros do banco de dados use o método <code>remove()</code> que
          recebe como parâmetros o nome do tabela e um filtro, caso necessário.
        </p>

        <p>
          Existem duas maneiras de criarmos um filtro; a primeira é usando uma função
          <code>callback</code> e a segunda é passando um array indexado com dois elementos
          onde o primeiro é nome de uma coluna e o segundo é o valor dessa coluna a ser comparado.
        </p>

        <p>
          No exemplo abaixo demonstramos as três maneiras de remover registros:
        </p>

        <pre>
          <code>
            //criando filtro com função callback
            $rowCount = $st->remove('users', function($f) {
              $f->filter('email', '=', 'foo@bar.com');
            });

            // usando array indexado
            $rowCount = $st->remove('users', ['id', 2]);

            //removendo todos os registros de users
            $rowCount = $st->remove('users');
          </code>
        </pre>
      </section>

      <section>
        <h3 id="3.4">Usando transações</h3>

        <p>
          Para inserir, atualiazar ou remover registros de forma segura use o método
          <code>transaction()</code>, que recebe como parâmetro uma função callback que executa uma instrução SQL dentro de uma transação de banco de dados. Caso ocorra uma falha tudo será desfeito (rollback).
        </p>

        <pre>
          <code>
            $rowCount = $st->transaction(function($statement) {
              return $statement->remove('authors', ['id', 10]);
            });
          </code>
        </pre>

        <p>
          O métod <code>transaction()</code> só retorna um valor se você retornar o valor do callback.
        </p>
      </section>

      <!--Fim secao modificando dados-->
      </section>
    </div>
    </div>
  </main>

  <script>
    // Exibe ou oculta menu lateral
    function toggleSidebar() {
      document.querySelector('#sidebarElem').classList.toggle('toggle');
      document.querySelector('#contentElem').classList.toggle('toggle');
    }

    //Ao clicar no link do sumario do menu lateral redireciona 
    // para o titulo ancorado com o link
    function redirect(e) {
      location.href = '#' + e.dataset.redir;
    }

    // Removendo identação inicial desnecessárias dos elementos <pre>
    let elements = document.querySelectorAll('pre code');

    elements.forEach((element) => formatPreElement(element));
    function formatPreElement(element) {
      let promise = new Promise((resolve, reject) => {
        let content = element.textContent;

        let lines = content.split('\n');

        let firstLine = lines[1];

        let pos = firstLine.search(/\S/);

        let buffer = '';
        let regexp = new RegExp("\\s{" + pos + "}");
        for (let i = 0; i < lines.length; i++) {
          let newLine = lines[i].replace(regexp, '');
          buffer += newLine + "\n";
        }
        element.textContent = buffer.trim();
        resolve();
      });
    }
  </script>
  <!--
  <script src="https://code.jquery.com/jquery-3.6.0.slim.min.js"
    integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
  -->

  <script>window.jQuery || document.write('<script src="./js/jquery.js"><\/script>')</script>

  <!-- JavaScript Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
    crossorigin="anonymous"></script>
</body>

</html>