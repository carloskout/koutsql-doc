<!doctype html>
<html lang="pt-br">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Documentação DataB">
  <meta name="author" content="Carlos Coutinho">
  <meta name="theme-color" content="#0d6efd">
  <meta name="msapplication-navbutton-collor" content="#0d6efd">
  <meta name="apple-mobile-web-app-status-bar-style" content="#0d6efd">
  <title>Documentação DataB</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.1/font/bootstrap-icons.css">

  <link rel="stylesheet" href="./css/idea.min.css">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="./css/style.css">

  <script src="./js/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>

  <div id="header-container">
    <header class="container-fluid bg-primary" id="header-top">
      <div>
        <a id="logo" href="#">
          DataB<i class="bi bi-server"></i>
        </a>
      </div>

      <div>
        <a href="https://github.com/carloskout/datab" id="link-github" target="_blank">
          DataB no Github
          <i class="bi bi-box-arrow-up-right"></i>
        </a>
      </div>
    </header>
  </div>

  <!--Siderbar-->
  <button class="btn-bar">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>

  <aside class="sidebar">
    <div class="sidebar-header">
      <h3>Conteúdo</h3>
    </div>
    <hr>
    <nav>
      <ul>
        <li>
          <details>
            <summary>
              <a href="#1">1. Introdução</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#1.1">1.1. Pré-requisitos</a>
              </li>
              <li>
                <a href="#1.2">1.2. Detalhes</a>
              </li>
              <li>
                <a href="#1.3">1.3. Como instalar</a>
              </li>
              <li>
                <a href="#1.4">1.4. Configuração e exemplo de uso</a>
              </li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary>
              <a href="#2">2. Consultas SQL</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#2.1">2.1. Recuperando resultado</a>
              </li>
              <li>
                <a href="#2.2">2.2. Consultas nativas</a>
              </li>
              <li>
                <a href="#2.3">2.3. Funções de agregação</a>
              </li>
              <li>
                <a href="#2.4">2.4. Funções nativas</a>
              </li>
              <li>
                <a href="#2.5">2.5. Ordenação de dados</a>
              </li>
              <li>
                <details>
                  <summary>
                    <a href="#2.6">2.6. Filtrando dados</a>
                  </summary>
                  <ul class="sublist">
                    <li>
                      <a href="#2.6.1">2.6.1. Operadores relacionais</a>
                    </li>
                    <li>
                      <details>
                        <summary>
                          <a href="#2.6.2">2.6.2. Operadores lógicos</a>
                        </summary>
                        <ul class="sublist">
                          <li>
                            <a href="#2.6.2.1">2.6.2.1. AND e OR</a>
                          </li>
                          <li>
                            <a href="#2.6.2.2">2.6.2.2. IN e NOT IN</a>
                          </li>
                          <li>
                            <a href="#2.6.2.3">2.6.2.3. BETWEEN E NOT BETWEEN</a>
                          </li>
                          <li>
                            <a href="#2.6.2.4">2.6.2.4. LIKE</a>
                          </li>
                          <li>
                            <a href="#2.6.2.5">2.6.2.5. IS NULL e IS NOT NULL</a>
                          </li>
                          <li>
                            <a href="#2.6.2.6">2.6.2.6. EXISTS e NOT EXISTS</a>
                          </li>
                        </ul>
                      </details>
                    </li>
                  </ul>
                </details>
              </li>
              <li>
                <a href="#2.7">2.7. Limitando retorno de linhas</a>
              </li>
              <li>
                <a href="#2.8">2.8. Buscando dados não duplicados</a>
              </li>
              <li>
                <a href="#2.9">2.9. Junção de tabelas</a>
              </li>
              <li>
                <a href="#2.10">2.10. Agrupando dados</a>
              </li>
              <li>
                <a href="#2.11">2.11. Union</a>
              </li>
              <li>
                <a href="#2.12">2.12. Subqueries</a>
              </li>
              <li>
                <a href="#2.13">2.12. Subexpressões</a>
              </li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary>
              <a href="#3">3. Modificando dados</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#3.1">3.1. Inserindo registros</a>
              </li>
              <li>
                <a href="#3.2">3.2. Atualizando registros</a>
              </li>
              <li>
                <a href="#3.3">3.3. Removendo registros</a>
              </li>
              <li>
                <a href="#3.4">3.4. Usando transações</a>
              </li>
            </ul>
          </details>
        </li>
      </ul>
    </nav>
  </aside>

<main class="content">
<div class="row">
<div class="col-md-9">

<section>
  <h1 id="1">Introdução</h1>
  <p>
    DataB é uma library PHP que facilita a criação e execução de instruções SQL usando PDO (PHP Data Object).
  </p>

  <section>
    <h3 id="1.1">Pré-requisitos</h3>
    <p>
      Para usar DataB é necessário ter conhecimento prévio da linguagem PHP e SQL.
    </p>
  </section>

  <section>
    <h3 id="1.2">Detalhes</h3>
    <p>
      Bancos de dados suportados: <b>MYSQL</b> <br>
      Versão atual: <b>1.0.1</b> <br>
      Licença: <b>MIT</b>
    </p>
  </section>

  <section>
    <h3 id="1.3">Como instalar</h3>
    <p>
      DataB pode ser instalada através do Composer, que é gerenciador de pacotes
      para a linguagem PHP. Basta executar o comando: <code>composer require kout/datab</code>
    </p>
    <p>
      Instalado? Ótimo! Agora você está pronto para dá os primeiros passos
      com DataB através de exemplos práticos</a>.
    </p>
  </section>

  <section>
    <h3 id="1.4">Configuração e exemplo de uso</h3>
    <p>
      Antes de comerçar a criar e executar instruções SQL, primeiro você deve
      informar para DataB uma conexão com Banco de Dados existente. Para isso, basta
      passar por parâmetro um objeto PDO para o método <code>DataB::setPDO()</code>:
    </p>
  </section>

<pre>
<code>
$pdo = new \PDO(...);
DataB::setPDO($pdo);
</code>
</pre>

  <p>Prontinho! Agora você já pode começar a criar e executar instruções SQL. Veja como é fácil:</p>

<pre>
<code>
$result = DataB::select('*')
  ->table('books')
  ->exec()
  ->getAll();
</code>
</pre>

  <p>
    No exemplo acima, buscamos por todos os registros da tabela <code>books</code>.
  </p>

  <p>
    Para ver a instrução SQL gerada no código acima, basta executar o método <code>sql()</code> em vez do
    método <code>exec()</code>:
  </p>

<pre>
<code>
$sql = DataB::select('*')
  ->table('books')
  ->sql();

var_dump($sql);
</code>
</pre>
</section>

<hr>

<section>
  <h1 id="2">Consultas SQL</h1>
  <p>
    Para fazer consultas SQL use o método <code>DataB::select()</code> para especificar a lista de campos que serão
    retornados pela consulta. Você pode passar por parâmetro tanto um array de
    nomes de colunas quanto uma lista de nomes de colunas separadas por vírgulas. Em seguida, use o
    método <code>DataB::table()</code> para definir em qual tabela será feita a consulta de dados.
</p>
<p>
    No exemplo abaixo passamos um array como parâmetro contendo os nomes das colunas que queremos recuperar no resultado da query:
</p>

<pre>
<code>
$columns = array(
'title',
'price',
'published'
);

$books = DataB::select($columns)
  ->table('books')
  ->exec()
  ->getAll();

var_dump($books);
</code>
</pre>

<p>
  Neste outro exemplo passamos duas strings por parâmetro representando os nomes das colunas que queremos recuperar no resultado da query:
</p>

<pre>
<code>
$books = DataB::select('title', 'published')
  ->table('books')
  ->exec()
  ->getAll();

var_dump($books);
</code>
</pre>

<p>
    O método <code>DataB::exec()</code> é chamado para executar a instrução SQL enquanto o método
    <code>DataB::getAll()</code> recupera o resultado retornado pelo o banco de dados.
</p>
<p>Para recuperar todos os campos da tabela use <code>DataB::select('*')</code></p>

<section>
  <h3 id="2.1">Recuperando resultado</h3>
  <p>
    Use <code>DataB::getAll()</code> para recuperar todos
    os registros retornados pela consulta:
</p>

<pre>
<code>
$authors = DataB::select('*')
  ->table('authors')
  ->exec()
  ->getAll();

var_dump($authors);
</code>
</pre>

<p>
    O código acima gera a seguinte saída:
</p>

<pre>
<code>
array (size=5)
  0 => 
    array (size=2)
    'id' => string '1' (length=1)
    'name' => string 'Yvonne do Amaral Pereira' (length=24)
  1 => 
    array (size=2)
    'id' => string '2' (length=1)
    'name' => string 'Henrik Ibsen' (length=12)
  2 => 
    array (size=2)
    'id' => string '3' (length=1)
    'name' => string 'John Green' (length=10)
  ...
</code>
</pre>

<p>
    Use <code>DataB::getFirst()</code> para recuperar o primeiro
    registro retornado pela consulta:
</p>

<pre>
<code>
$category = DataB::select('*')
  ->table('categories')
  ->exec()
  ->getFirst();

var_dump($category);
</code>
</pre>

<p>
    Use <code>DataB::getLast()</code> para recuperar o último
    registro retornado pela consulta:
</p>

<pre>
<code>
$author = DataB::select('*')
  ->table('categories')
  ->exec()
  ->getLast();

var_dump($category);
</code>
</pre>

<p>
    Use <code>DataB::getSingleResult()</code> para recuperar o valor literal retornado pela query.
    Observe que, diferente dos outros métodos visto acima, este método não retorna um array contento o resultado da
    consulta: Observe o trecho de código abaixo:
</p>

<pre>
<code>
$result = DataB::select(1 + 1)
  ->exec()
  ->getSingleResult();

var_dump($result);

// A saída do método var_dump() será o valor '2'

</code>
</pre>

<p>
    Veja este outro exemplo onde buscamos pelo campo <code>title</code> da tabela
    <code>books</code>. Neste exemplo, usamos uma condição para limitar a quantidade de registros retornados pela
    query. Se nenhuma condição for definida, então o método <code>DataB::getSingleResult()</code>
    retornará o valor da primeira coluna do primeiro registro encontrado.
</p>

<pre>
<code>
$title = DataB::select('title')
  ->table('books')
  ->cond('id')
  ->eqValue(1)
  ->exec()
  ->getSingleResult();

var_dump($title);
</code>
</pre>

<p>
    Use <code>DataB::getObjects()</code> para recuperar todos os
    registros como objetos. Este método recebe por
    parâmetro o nome da classe que será usada para criar as instâncias dos objetos.
    Se nenhum parâmetro for especificado, então os registros serão retornados como
    objetos 'stdClass':
</p>

<pre>
<code>

class Author {

}

$authors = DataB::select('*')
  ->table('authors')
  ->exec()
  ->getObjects('Author');

var_dump($authors);
</code>
</pre>

<p>
    O código acima gera a seguinte saída:
</p>

<pre>
<code>
array (size=5)
  0 => 
    object(Author)[2]
    public 'id' => string '1' (length=1)
    public 'name' => string 'Yvonne do Amaral Pereira' (length=24)
  1 => 
    object(Author)[6]
    public 'id' => string '2' (length=1)
    public 'name' => string 'Henrik Ibsen' (length=12)
  ...
</code>
</pre>

<p>
    Use <code>DataB::getObject()</code> para recuperar o primeiro
    registro como objeto. Este método recebe como
    parâmetro o nome da classe que será usada para criar a instância do objeto.
    Se nenhum parâmetro for especificado, então o primeiro registro será retornado como
    um objeto 'stdClass'.
</p>

<p>
    Use <code>DataB::getLazy()</code> para recuperar o primeiro
    registro como um objeto PDORow onde as variáveis desse objeto correspondem
    aos nomes das colunas da tabela. Esse método faz o carregamento dos
    dados conforme as variáveis do objeto <code>PDORow</code> forem acessadas.
</p>

</section>

<section>
  <h3 id="2.2">Consultas nativas</h3>
  <p>
    Para executar consultas nativas use <code>DataB::nativeSQL()</code>.
    Este método executa qualquer instrução SQL, tanto
    DML quanto DDL.
  </p>

  <p>Executando instrução DML:</p>

<pre>
<code>
$sql = 'SELECT * FROM authors';
$authors = DataB::nativeSQL($sql)->getAll();
</code>
</pre>

  <p>Executando instrução DDL:</p>

<pre>
<code>
$sql = 'ALTER TABLE categories ADD COLUMN parent INTEGER';
$rowCount = DataB::nativeSQL($sql)->rows();
</code>
</pre>
</section>

<section>
  <h3 id="2.3">Funções de agregação</h3>

  <p>
    As funções de agregação em DataB podem ser acessadas de forma
    estática ou através de referências de objetos. Lembre-se, caso queira
    acessar por referência você deve chamar a funcão na orderm correta, ou seja,
    logo após a chamada do método <code>DataB::select()</code>.
  </p>

  <p>
      Veja no exemplo a seguir onde contamos quantos registros existem na
      tabela <code>categories</code>:
  </p> 

<pre>
<code>
$count = DataB::count('*')
  ->table('categories')
  ->exec()
  ->getSingleResult();
</code>
</pre>

<p>
    Neste outro exemplo contamos quantos livros foram publicados por 
    cada autor:
</p>

<pre>
<code>
$result = DataB::select('authors.name')
  ->count('*')
  ->alias('qtd_livros_publicados')
  ->table('books')
  ->innerJoin('authors')
  ->on('books.authors_id')
  ->eqColumn('authors.id')
  ->groupBy('authors.name')
  ->exec()
  ->getAll();
</code>
</pre>

<p>Saída SQL:</p>

<pre>
<code>
SELECT authors.name, COUNT(*) AS 'qtd_livros_publicados' FROM books
  INNER JOIN authors ON books.authors_id = authors.id 
  GROUP BY authors.name
</code>
</pre>

  <p>As demais funções de agregação implementadas em DataB são listadas abaixo:</p>
  
  <ul>
      <li>
          <code>DataB::min()</code> - Busca pelo menor valor dentre um conjuntos de valores.
      </li>
      <li>
          <code>DataB::max()</code> - Busca pelo maior valor dentre um conjuntos de valores.
      </li>
      <li>
          <code>DataB::avg()</code> - Busca pela média aritmética dentre um conjuntos de valores.
      </li>
      <li>
          <code>DataB::sum()</code> - Busca pela soma total dentre um conjuntos de valores.
      </li>
  </ul>
</section>

<section>
  <h3 id="2.4">Funções nativas</h3>

  <p>
    Você pode executar qualquer função nativa do banco de dados fazendo
    chamada ao nome da função precedida pelo prefixo (fn). A chamada pode ser tanto
    de forma estática quanto por referência. Lembre-se, caso queira
    acessar por referência você deve chamar a funcão na orderm correta, ou seja,
    logo após a chamada do método <code>DataB::select()</code>.
  </p>

  <p>
    No exemplo abaixo fazemos uma chamada estática à funcão nativa <code>concat</code> onde
    mesclamos os títulos e os preços de cada livro armazenado na tabela <code>books</code>:
  </p>
<pre>
<code>
$result = DataB::fnConcat('title', "' | R$ '", 'price')
  ->alias('Título com Preço')
  ->table('books')
  ->exec()
  ->getAll();

var_dump($result);
</code>
</pre>

<p>Saída <code>var_dump()</code>:</p>
<pre>
<code>
array (size=7)
  0 => 
    array (size=1)
    'Título com Preço' => string 'Memórias de um suicida | R$ 52.80' (length=34)
  1 => 
    array (size=1)
    'Título com Preço' => string 'Nas voragens do pecado | R$ 35.95' (length=33)
...
</code>
</pre>

<p>
Neste outro exemplo executamos a mesma função só que fazendo chamada
por referência:
</p>

<pre>
<code>
$result = DataB::select('title')
  ->fnConcat('published', "' | '", 'price')
  ->alias('Ano pub. com Preço')
  ->table('books')
  ->exec()
  ->getAll();
</code>
</pre>

<p>Saída <code>var_dump()</code>:</p>

<pre>
<code>
array (size=7)
  0 => 
    array (size=2)
    'title' => string 'Memórias de um suicida' (length=23)
    'Ano pub. com Preço' => string '1958 | 52.80' (length=12)
  1 => 
    array (size=2)
    'title' => string 'Nas voragens do pecado' (length=22)
    'Ano pub. com Preço' => string '1959 | 35.95' (length=12)
    ...
</code>
</pre>
<p>
Se a função chamada não existir no banco de dados, uma exceção <code>DataBException</code>
será lançada.
</p>
</section>

<section>
  <h3 id="2.5">Ordenação de dados</h3>
  <p>
    Para ordenar dados use os métodos <code>orderByAsc()</code> e
    <code>orderByDesc()</code>. Esses métodos recebem como parâmetro
    a(s) coluna(s) que serão usadas na ordenação dos dados.
    Observe os exemplos a seguir:
</p>

<p>Ordenação ascendente:</p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->orderByAsc('published')
  ->exec()
  ->getAll();
</code>
</pre>

<p>Ordenação descendente:</p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->orderByDesc('published')
  ->exec()
  ->getAll();
</code>
</pre>

<p>Usando mais de uma coluna para ordenar dados:</p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->orderByAsc('title', 'published')
  ->exec()
  ->getAll();
</code>
</pre>
</section>

<section>
  <h3 id="2.6">Filtrando Dados</h3>

  <p>
    Para adicionar restrições à consulta SQL, você deve inicialmente usar o método 
    <code>DataB::cond()</code> que equivale à cláusula <code>WHERE</code>. Após a chamada
    desse método você pode encadear outros métodos para adicionar mais restrições à query.
  </p>

  <p>
    Observe no trecho de código abaixo no qual buscamos por todos os registros da tabela
    <code>books</code> onde o preço tem que ser igual a <code>29.99</code>:
  </p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->cond('price')
  ->eqValue(29.99)
  ->exec()
  ->getAll();
</code>
</pre>

<p>Abaixo ilustramos a instrução SQL equivalente ao trecho de código acima:</p>

<pre>
<code>
SELECT * FROM books WHERE price = ?
</code>
</pre>

<p>
  Observe a instrução SQL gerada no exemplo acima onde temos o campo
  <code>price = ?</code>. Por padrão, todos os parâmetros de entrada
  para a instrução SQL são convertidos para <strong>mask placeholders</strong> para evitar
  SQL Injection.
</p>

<p>
  Existem duas maneiras para criar parâmetros SQL com dados de entrada usando DataB.
  A primeira é através de métodos que recebem algum valor de entrada, como por exemplo o
  método <code>eqValue()</code> que equivale ao operador relacional de igualdade. A segunda é
  passando um array de dados para o método <code>exec()</code>. Ao trabalhar desta forma,
  fica ao seu critério usar <strong>mask placeholders</strong> ou <strong>named placeholders</strong>.
  Se você optar por esta, deverá passar um array associativo onde as chaves do array devem
  corresponder aos nomes das colunas da tabela; caso opte por aquela, então você terá que
  passar um array indexado como parâmentro. Veja como funciona:
</p>

<p>Usando <code>mask placeholders</code> :</p>

<pre>
<code>
$data = array('Romance');

$category = DataB::select('*')
  ->table('categories')
  ->cond('name')
  ->eqValue('?')
  ->exec($data)
  ->getAll();
</code>
</pre>

<p>Abaixo ilustramos a instrução SQL equivalente ao trecho de código acima:</p>

<pre>
<code>
SELECT * FROM categories WHERE name = ?
</code>
</pre>

<p>Usando <code>named placeholders</code>:</p>

<pre>
<code>

$data = array(
  'price' => 29.99,
  'published' => 2011
);

$book = DataB::select('*')
  ->table('books')
  ->cond('price')
  ->eqValue(':price')
  ->and('published')
  ->eqValue(':published')
  ->exec($data)
  ->getAll();
</code>
</pre>

<p>Abaixo ilustramos a instrução SQL equivalente ao trecho de código acima:</p>

<pre>
<code>
SELECT * FROM books WHERE price = :price
  AND published = :published'
</code>
</pre>

<section>
  <h4 id="2.6.1">Operadores relacionais</h4>

  <p>
    DataB disponibiliza métodos para comparação de valores literais, como strings, números, booleanos; e
    para comparação de colunas do banco de dados. Por exemplo, para usar o operador relacional de igualdade
    <code>(=)</code> para comparar valores literais use o método <code>DataB::eqValue()</code>; para comparar colunas do banco
    de dados use o método <code>DataB::eqColumn()</code>.
  </p>

  <p>
    Veja no exemplo abaixo no qual buscamos todos os registros da tabela <code>books</code> onde o
    ano de publicação seja igual a 2019:
  </p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->cond('published')
  ->eqValue(2019)
  ->exec()
  ->getAll();

var_dump($books);
</code>
</pre>

  <p>
    Neste outro exemplo fazemos consultas na tabela <code>authors</code> e <code>books</code> onde buscamos pelos nomes dos autores e pelos titulos de seus respectivos livros publicados:
  </p>

<pre>
<code>
$result = DataB::select('authors.name', 'books.title')
  ->table('authors', 'books')
  ->cond('authors.id')
  ->eqColumn('books.authors_id')
  ->exec()
  ->getAll();

var_dump($result);
</code>
</pre>

  <p>
    Veja a lista completa de todos os métodos usados para comparar valores com DataB:
  </p>

  <ul>
    <li>
        <code>eqValue()</code>, <code>eqColumn()</code> (=)
    </li>
    <li>
        <code>neValue()</code>, <code>neColumn()</code> (!=)
    </li>
    <li>
        <code>ltValue()</code>, <code>ltColumn()</code> (&lt;)
    </li>
    <li>
        <code>gtValue()</code>, <code>gtColumn()</code> (&gt;)
    </li>
    <li>
        <code>leValue()</code>, <code>leColumn()</code> (&lt;=)
    </li>
    <li>
        <code>geValue()</code>, <code>geColumn()</code> (&gt;=)
    </li>
</ul>
</section>

<section>
  <h4 id="2.6.2">Operadores lógicos</h4>

  <section>
    <h5 id="2.6.2.1">AND e OR</h5>

    <p>
      Para encadear duas ou mais expressões lógicas use os métodos <code>DataB::and()</code> e
      <code>DataB::or()</code>. Obseve no exemplo abaixo no qual demonstramos a consulta em duas tabelas vinculadas, <code>authors</code> e <code>books</code>, para recuperar somente os registros que obedecem ao conjunto de restrições encadeadas. Nessas restrições, definimos que haja a vinculação entre as duas tabelas e que o ano de publicação do livro seja maior que <code>2000</code> ou o preço seja menor que <code>50.45</code>. 
    </p>
  
<pre>
<code>
$result = DataB::select('*')
  ->table('authors', 'books')
  ->cond('authors.id')
  ->eqColumn('books.authors_id')
  ->and('published')
  ->gtValue(2000)
  ->or('price')
  ->ltValue(50.45)
  ->exec()
  ->getAll();
</code>
</pre>
  
  <p>Abaixo ilustramos a instrução SQL equivalente ao trecho de código acima:</p>
  
<pre>
<code>
SELECT authors.name, books.title FROM authors, books 
  WHERE authors.id = books.authors_id 
  AND published &gt; ? OR price &lt; ?
</code>
</pre>

  <p>
    Você pode usar os métodos <code>DataB::and()</code> e <code>DataB::or()</code> sem a passagem
    de parâmetros. Nesse caso, apenas o perador lógico será adicionado na query. Veja como funciona:
  </p>

<pre>
<code>
$result = DataB::select('*')
  ->table('books')
  ->cond('note')
  ->isNull()
  ->and()
  ->exists(function() {
      return DataB::select(1)
        ->table('authors')
        ->cond('name')
        ->startsWith('J')
        ->and('authors.id')
        ->eqColumn('books.authors_id');
  })
  ->exec()
  ->getAll();
</code>
</pre>

  <p>
    No exemplo acima buscamos por todos os registros da tabela <code>books</code> onde o 
    campo <code>note</code> tem valor <code>nulo</code> e que exista para cada livro um autor
    cujo nome inicia com a letra <code>J</code>.
  </p>

  <p>Veja como fica a instrução SQL correspondente ao exemplo anterior:</p>

<pre>
<code>
  SELECT * FROM books WHERE note IS NULL 
    AND EXISTS (SELECT 1 FROM authors WHERE name LIKE ? AND authors.id = books.authors_id)
</code>
</pre>
</section>

<section>
  <h5 id="2.6.2.2">IN e NOT IN</h5>

  <p>
    No exemplo ilustramos o uso do operador <code>IN</code> através do método
    <code>DataB::in()</code> para fazermos consulta na tabela <code>books</code>
    recuperando somente os registros cujo ano de publicação seja 1958, 2011 ou 2019.
    Os valores passados por parâmetros podem ser tanto um array quanto um conjunto de valores
    separadas por vírgulas. Veja como funciona:
  </p>
  
<pre>
<code>
// Usando conjunto de valores separados por vírgulas:

$books = DataB::select('*')
  ->table('books')
  ->cond('published')
  ->in(1958, 2011, 2019)
  ->exec()
  ->getAll();

// Usando array como parâmetro:

$books = DataB::select('*')
  ->table('books')
  ->cond('published')
  ->in([1958, 2011, 2019])
  ->exec()
  ->getAll();
</code>
</pre>
  
  <p>
    Envez de passar os valores direto para o método <code>DataB::in()</code>, você pode também substituí-los 
    por <strong>Named Placeholders</strong> ou <strong>Mask Placeholders</strong>. Vale ressaltar que todo
    parâmetro de entrada é convertido automaticamente para <strong>Mask Placeholders</strong> para evitar
    SQL Injection. Observe no trecho de código abaixo no qual demonstramos o uso do método DataB::notIn()
    com a entrada de parâmetros <strong>Named Placeholders</strong>:
  </p>
  
<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->cond('published')
  ->notIn(':pub1', ':pub2', ':pub3')
  ->exec([
      'pub1' => 1958,
      'pub2' => 2011,
      'pub3' => 2019
    ])
  ->getAll();
</code>
</pre>
</section>

<section>
  <h5 id="2.6.2.3">BETWEEN e NOT BETWEEN</h5>

  <p>
    Para incluir estes operadores na instrução SQL use os métodos
    <code>DataB::between()</code> e <code>DataB::notBetween()</code>. Observe 
    no trecho de código abaixo no qual fazemos uma consulta na tabela <code>books</code>
    recuperando somente os registros onde o preço esteja no intervalo de valores 
    <code>34.59</code> a <code>48.75</code>:
  </p>
<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->cond('price')
  ->between(34.59, 48.75)
  ->exec()
  ->getAll();
</code>
</pre>
</section>

<section>
  <h5 id="2.6.2.4">LIKE</h5>

  <p>
    DataB disponibiliza três métodos para se trabalhar com o operador <code>LIKE</code>:
</p>

<ul>
    <li>
        <code>DataB::startsWith()</code> - Busca por um valor que começa com um padrão.
    </li>
    <li>
        <code>DataB::contains()</code> - Busca por um valor que contêm um padrão.
    </li>
    <li>
        <code>DataB::endsWith()</code> - Busca por um valor que termina com um padrão.
    </li>
</ul>

<p>
    A seguir demonstramos o uso do método <code>DataB::startsWith()</code> para buscar somente
    os registros da tabela <code>categories</code> onde o nome inicia com a letra <code>R</code>.
    Observe:
</p>

<pre>
<code>
$categories = DataB::select('*')
  ->table('categories')
  ->cond('name')
  ->startsWith('R')
  ->exec()
  ->getAll();
</code>
</pre>

<p>
  Veja o mesmo exemplo acima só que usando o método <code>DataB::exec()</code> para receber o
  padrão como parâmetro:
</p>

<pre>
<code>
$categories = DataB::select('*')
  ->table('categories')
  ->cond('name')
  ->startsWith('?')
  ->exec(['R%'])
  ->getAll();
</code>
</pre>

<p>
  No exemplo acima foi usado <code>mask placeholders</code>, mas você pode usar também 
  <code>named placeholders</code>.
</p>
</section>

<section>
  <h5 id="2.6.2.5">IS NULL e IS NOT NULL</h5>

  <p>
    Use os métodos <code>DataB::isNull()</code> e <code>DataB::isNotNull()</code>. No 
    exemplo abaixo fazemos uma consulta na tabela <code>books</code> buscando por todos 
    os registros onde a coluna <code>note</code> tenha valor nulo:
  </p>
  
<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->cond('note')
  ->isNotNull()
  ->exec()
  ->getAll();
</code>
</pre>
</section>

<section>
  <h5 id="2.6.2.6">EXISTS e NOT EXISTS</h5>

  <p>
    Geralmente o operador <code>EXISTS</code> é usado com subqueries. Não entraremos a fundo 
    neste conteúdo pois temos uma seção específica para abordá-lo. No entanto demonstraremos
    como usá-lo.
  </p>

  <p>
    DataB disponibiliza os métodos <code>DataB::exists()</code> e <code>DataB::notExists()</code>  
    os quais recebem como parâmetro uma função <code>callback</code>
    que retorna uma subquery. Veja como funciona:
  </p>

<pre>
<code>
$result = DataB::select('*')
  ->table('authors')
  ->cond()
  ->exists(function() {
      return DataB::select('*')
        ->table('books')
        ->cond('published')
        ->between(2000, 2019)
        ->and('authors.id')
        ->eqColumn('books.authors_id');
  })
  ->exec()
  ->getAll();
</code>
</pre>

  <p>
    No trecho de código acima buscamos por todos os autores que tenham livros publicados entre os anos de 
    <code>2000</code> e <code>2019</code>.
  </p>

  <p>
    Agora observe como fica a instrução SQL correspondente ao exemplo anterior:
  </p>

<pre>
<code>
SELECT * FROM authors WHERE 
  EXISTS (SELECT * FROM books WHERE published BETWEEN ? AND ? AND authors.id = books.authors_id)
</code>
</pre>

  </section>

<!--fim secao operadores logicos-->
</section>

<!--Fim secao filtrando dados-->
</section>

<section>
  <h3 id="2.7">Limitando retorno de linhas</h3>
  <p>
    Use <code>DataB::limit()</code>:
  </p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->limit(10)
  ->exec()
  ->getAll();
</code>
</pre>

<p>
  Você pode especificar a partir de qual registro será retornado o resultado
  da consulta. Observe:
</p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->limit(10, 2)
  ->exec()
  ->getAll();
</code>
</pre>

<p>Abaixo ilustramos a instrução SQL equivalente ao trecho de código acima:</p>

<pre>
<code>
SELECT * FROM produtos LIMIT 2, 10
</code>
</pre>

<p>
  No trecho de código acima, buscamos por dez registros da tabela <code>books</code>, inicando
  na linha seguinte depois da linha <code>2</code>.
</p>
</section>

<section>
  <h3 id="2.8">Buscando dados não duplicados</h3>
  <p>Use o método <code>DataB::distinct()</code>:</p>

<pre>
<code>
// buscando registros que não tenham o ano de publicação duplicado
$books = DataB::distinct('published')
  ->table('books')
  ->exec()
  ->getAll();
</code>
</pre>
</section>

<section>
  <h3 id="2.9"> Junção de tabelas</h3>
  <p>
    Nesta seção demonstramos como fazer junção de tabelas com DataB. No exemplo abaixo,
    usamos o método <code>DataB::cond()</code> para criar a junção entre
    as tabelas <code>authors</code> e <code>books</code>:
  </p>

<pre>
<code>
$result = DataB::select('*')
  ->table('authors', 'books')
  ->cond('authors.id')
  ->eqColumn('books.authors_id')
  ->exec()
  ->getAll();
</code>
</pre>

<p>Veja como fica a instrução SQL equivalente ao trecho de código acima:</p>

<pre>
<code>
SELECT * FROM authors, books WHERE authors.id = books.authors_id
</code>
</pre>

<p>
  Agora, no exemplo abaixo, fazemos a junção de tabelas usando <code>inner join</code>:
</p>

<pre>
<code>
$result = DataB::select('*')
  ->table('authors')
  ->innerJoin('books')
  ->on('authors.id')
  ->eqColumn('books.authors_id')
  ->exec()
  ->getAll();
</code>
</pre>

<p>
  Ok. Os demais métodos disponíveis em DataB para criar junções de tabelas são estes:
  <code>DataB::leftJoin()</code>, <code>DataB::rightJoin()</code> e <code>DataB::crossJoin()</code>.
</p>

<p>
  <strong>Observação:</strong> Se os campos de comparação das tabelas envolvidas tiverem o mesmo nome, então você pode usar o método <code>DataB::using()</code> em vez do método <code>DataB::on()</code>. Veja como funciona:
</p>


<pre>
<code>
$result = DataB::select('*')
  ->table('authors')
  ->innerJoin('books')
  ->using('author_id')
  ->exec()
  ->getAll();
</code>
</pre>

<p>
  Para que o método <code>DataB::using()</code> funcione corretamente, o nome do campo que
  representa a chave primária na primeira tabela deverá ser idêntico ao nome do campo de referência
  na segunda tabela.
</p>
<!--Fim secao junção de tabelas-->
</section>

<section>
  <h3 id="2.10">Agrupando dados</h3>

  <p>
    Para agrupar dados use os métodos <code>DataB::groupBy()</code>; e para definir condições
    para o agrupamento de dados use o método <code>DataB::having()</code>. Observe
    no exemplo abaixo no qual contamos quantos livros existem por categoria:
  </p>

<pre>
<code>
$result = DataB::select('categories.name')
  ->alias('Categoria')
  ->count('*')
  ->alias('Qtd livros')
  ->table('categories', 'books')
  ->cond('categories.id')
  ->eqColumn('books.categories_id')
  ->groupBy('categories.id')
  ->exec()
  ->getAll();
</code>
</pre>

<p>
  Veja como fica a instrução SQL equivale ao exemplo anterior:
</p>

<pre>
<code>
array (size=3)
  0 => 
    array (size=2)
      'Categoria' => string 'Romance' (length=7)
      'Qtd livros' => string '3' (length=1)
  1 => 
    array (size=2)
      'Categoria' => string 'Drama' (length=5)
      'Qtd livros' => string '3' (length=1)
  2 => 
    array (size=2)
      'Categoria' => string 'Autobiografia' (length=13)
      'Qtd livros' => string '1' (length=1)
</code>
</pre>

<p>
  Se você já está familiarizado com o uso do método <code>DataB::cond()</code> então não terá
  nenhum problema ao usar o método <code>Data::having()</code> pois funcionam da mesma maneira.
</p>
</section>

<section>
  <h3 id="2.11">Union</h3>

  <p>
    Para unir dois ou mais conjuntos de resultados DataB disponibiliza os seguintes métodos:
    <code>DataB::union()</code>, <code>DataB::unionAll()</code> e <code>DataB::unionDistinct()</code>.
  </p>

  <p>
    Todos esses métodos recebem como parâmetro uma <code>função callback</code> que retorna uma 
    <code>subquery</code>. Observe no exemplo a seguir:
  </p>

<pre>
<code>
$result = DataB::select('books.title')
  ->table('books')
  ->union(function() {
      return DataB::select('authors.name')
      ->table('authors');
  })
  ->exec()
  ->getAll();
</code>
</pre>
</section>

<section>
  <h3 id="2.12">Subqueries</h3>

  <p>
    No ambiente de banco de dados é bastante comum o uso de subqueries para construir 
    consultas SQL complexas. Pois bem, DataB fornece
    suporte a subqueries no qual usamos funções callbacks para criá-las. A maioria dos métodos em DataB recebem
    função callback como parâmetro tanto para se criar subqueries quanto subexpressões. A seguir disponibilizamos
    uma lista com todos os método que suportam subqueries:
  </p>

  <ul>
    <li>
      <code>DataB::eqValue()</code>
    </li>
    <li>
      <code>DataB::neValue()</code>
    </li>
    <li>
      <code>DataB::ltValue()</code>
    </li>
    <li>
      <code>DataB::gtValue()</code>
    </li>
    <li>
      <code>DataB::leValue()</code>
    </li>
    <li>
      <code>DataB::geValue()</code>
    </li>
    <li>
      <code>DataB::in()</code>
    </li>
    <li>
      <code>DataB::notIn()</code>
    </li>
    <li>
      <code>DataB::exists()</code>
    </li>
    <li>
      <code>DataB::notExists()</code>
    </li>
    <li>
      <code>DataB::union()</code>
    </li>
    <li>
      <code>DataB::unionAll()</code>
    </li>
    <li>
      <code>DataB::unionDistinct()</code>
    </li>
    <li>
      <code>DataB::values()</code>
    </li>
    <li>
      <code>DataB::set()</code>
    </li>
  </ul>

  <p>
    A função callback passada por parâmetro deve retornar um objeto <code>DataB</code> que representa
    a query SQL.
  </p>

  <p>
    Observe no exemplo a seguir no qual buscamos todos os registros da tabela <code>books</code>
    somente se existir algum registro cadastrado na tabela <code>authors</code>:
  </p>

<pre>
<code>
$result = DataB::select('*')
  ->table('books')
  ->exists(function() {
      return DataB::select('*')->table('authors');
  })
  ->exec()
  ->getAll();
</code>
</pre>

  <p>
    Neste outro exemplo buscamos somente os registros da tabela <code>books</code> onde
    o nome da categoria começa com a letra <code>R</code>. Observe também que dentro da subquery 
    usamos <code>mask placeholders</code> como entrada de parâmetro para o método <code>DataB::startsWith()</code>
    em vez de passar o valor literal. Fica a seu critério usar <code>mask placeholder</code>, <code>named placeholders</code> ou o próprio valor literal:
  </p>

<pre>
<code>
$result = DataB::select('*')
  ->table('books')
  ->cond('categories_id')
  ->eqValue(function() {
      return DataB::select('id')
      ->table('categories')
      ->cond('name')
      ->startsWith('?');
  })
  ->exec(['R%'])
  ->getAll();
</code>
</pre>

<p>
  O código SQL correspondente ao exemplo acima é ilustrado a seguir:
</p>

<pre>
<code>
SELECT * FROM books 
  WHERE categories_id = (SELECT id FROM categories WHERE name LIKE ?)
</code>
</pre>
</section>

<section>
  <h3 id="2.13">Subexpressões</h3>
  <p>
    Subexpressões são criadas passando uma função callback como parâmetro para os métodos
    <code>DataB::and()</code> e <code>DataB::or()</code>. Observe:
  </p>

<pre>
<code>
$result = DataB::select('*')
  ->table('books')
  ->cond('categories_id')
  ->eqValue(1) // Romance
  ->and(function() {
      return DataB::column('published')
      ->eqValue(2019)
      ->or('price')
      ->leValue(40.00);
  })
  ->exec()
  ->getAll();
</code>
</pre>

  <p>
    Observe que passamos uma função callback para o método <code>DataB::and()</code>. Dentro dessa função 
    criamos e retornamos a subexpressão.
  </p>

  <p>
    Veja como fica a instrução SQL referente ao exemplo anterior:
  </p>

<pre>
<code>
SELECT * FROM books 
  WHERE categories_id = ? 
  AND (published = ? OR price &lt;= ?)
</code>
</pre>
</section>
<!--Fim secao consultas-->
</section>

<section>
  <h1>Modificando dados</h1>

  <p>
    Nesta seção você aprenderá como inserir, atualizar e remover registros do banco de dados
    usando <code>DataB</code>.
  </p>

  <section>
    <h3 id="3.1">Inserindo registros</h3>

    <p>
      Para inserir novos registros em uma tabela com DataB muito fácil, basta passar 
      para o método <code>DataB::insert()</code> a relação de campos da tabela que 
      você quer inserir. Essa relação pode ser tanto um <code>array</code> quanto uma lista 
      de <code>strings</code>.
    </p>

    <p>
      Veja no exemplo abaixo no qual inserimos um registro na tabela <code>books</code>:
    </p>

<pre>
<code>
$id = DataB::insert('title', 'price', 'published', 'categories_id', 'authors_id')
  ->table('books')
  ->values('Cinquenta Tons de Cinza', 24.95, 2011, 1, 1)
  ->exec()
  ->getLastInsertedId();
</code>
</pre>

  <p>
    Agora observe o mesmo exemplo só que passando um array como parâmetro para o método <code>DataB::insert()</code>:
  </p>

<pre>
<code>
$columns = ['title', 'price', 'published', 'categories_id', 'authors_id'];

$id = DataB::insert($columns)
  ->table('books')
  ->values('Cinquenta Tons de Cinza', 24.95, 2011, 1, 1)
  ->exec()
  ->getLastInsertedId();
</code>
</pre>

  <p>
    No exemplos acima passamos os valores literais para o método <code>DataB::values()</code>, mas
    você pode usar também <code>mask placeholders</code> ou <code>named placeholders</code>.
  </p>

  <p>
    Usando mask placeholders:
  </p>

<pre>
<code>
$data = ['Cinquenta Tons de Cinza', 24.95, 2011, 1, 1];

$id = DataB::insert('title', 'price', 'published', 'categories_id', 'authors_id')
  ->table('books')
  ->values('?', '?', '?', '?', '?')
  ->exec($data)
  ->getLastInsertedId();
</code>
</pre>

<p>
  Usando named placeholders:
</p>

<pre>
<code>
$data = [
  'title' => 'Cinquenta Tons de Cinza',
  'price' => 24.95,
  'published' => 2011, 
  'cat_id' => 1,
  'authors_id' => 1
];

$id = DataB::insert('title', 'price', 'published', 'categories_id', 'authors_id')
  ->table('books')
  ->values(':title', ':price', ':published', ':cat_id', ':authors_id')
  ->exec($data)
  ->getLastInsertedId();
</code>
</pre>

  <p>
    No exemplo abaixo mostramos como inserir vários registros ao mesmo tempo:</code>
  </p>

<pre>
<code>
$id = DataB::insert('name')
  ->table('authors')
  ->values('Carlos Coutinho')
  ->values('Junior César')
  ->values('Cláudio Borges')
  ->exec()
  ->getLastInsertedId();
</code>
</pre>

  <p>
    Você pode também inserir um novo registro usando dados de uma consulta. Neste caso, devemos passar 
    para o método <code>Datab::values()</code> uma função callback que retorna uma subquery.
    Observe:
  </p>

<pre>
<code>
$id = DataB::insert('name')
  ->table('authors')
  ->values(function() {
    return DataB::select('name')
    ->table('authors')
    ->cond('id')
    ->eqValue(2);
  })
  ->exec()
  ->getLastInsertedId();
</code>
</pre>

<p>
  No exemplo acima buscamos pelo registro da tabela <code>authors</code> cujo campo identificador <code>(id)</code> seja igual a <code>2</code>, entao usamos o resultado dessa query para inserir um novo registro no banco de dados
</p>

<p>
  Se você não especificar um filtro para limitar a quantidade de registros retornados pela query então todos 
  os registros retornados serao inseridos no banco de dados.
</p>
  </section>

  <section>
    <h3 id="3.2">Atualizando registros</h3>

    <p>
      Para fazer atualizações de registros em uma tabela específca devemos usar o método
      <code>DataB::update()</code> no qual passampos por parâmetro a lista de colunas que
      queremos atualizar; em seguida usamos o método <code>DataB::table()</code> para 
      definirmos em qual tabela ocorrerá as alterações; na sequência invocamos o método
      <code>DataB::set()</code>  no qual informamaos um conjunto de dados correspondentes à
      lista de campos que queremos atualizar.
    </p>

    <p>
      No trecho de código abaixo atualizamos o registro da tabela <code>books</code>
      onde o campo identificador <code>id</code> seja igual a <code>1</code>:
    </p>
  
<pre>
<code>
$rowCount = DataB::update('price', 'note')
  ->table('books')
  ->set(65.98, 'Este livro foi atualizado')
  ->cond('id')
  ->eqValue(1)
  ->exec()
  ->rows();
</code>
</pre>

  <p>
    O método <code>DataB::rows()</code> retorna o número de linhas afetadas pela query.
  </p>

  <p>
    No exemplo acima passamos como parâmetro para o método <code>DataB::set()</code> os valores 
    literais, mas você pode usar também <code>mask placeholders</code> ou <code>named placeholders</code>.
  </p>

  <p>
    No exemplo abaixo demonstramos o mesmo exemplo só que usando <code>mask placeholders</code> e
    passando a lista de campos para o método <code>DataB::update()</code> como um array:
  </p>

<pre>
<code>
$rowCount = DataB::update(['price', 'note'])
  ->table('books')
  ->set('?', '?')
  ->cond('id')
  ->eqValue('?')
  ->exec([68.98, 'Este livro foi atualizado', 1])
  ->rows();
</code>
</pre>

  <p>
    Neste outro exemplo demonstramos o uso de <code>named placeholders</code>:
  </p>

<pre>
<code>
$rowCount = DataB::update(['price', 'note'])
  ->table('books')
  ->set(':price', ':note')
  ->cond('id')
  ->eqValue(':id')
  ->exec([
    'price' => 68.98,
    'note' => 'Este livro foi atualizado',
    'id' => 1])
  ->rows();
</code>
</pre>

  <p>
    Agora vamos mostrar como atualizar coluna usando o resultado de uma <code>subquery</code>:
  </p>

<pre>
<code>
$rowCount = DataB::update('price', 'note')
  ->table('books')
  ->set(64.95, 
    function() {
      return DataB::select('name')
      ->table('authors')
      ->cond('id')
      ->eqValue(1);
    }
  )
  ->cond('id')
  ->eqValue(2)
  ->exec()
  ->rows();
</code>
</pre>

  <p>
    No exemplo acima atualizamos o valor da coluna <code>price</code> para <code>64.95</code>
    e para a coluna <code>note</code> definimos como valor o resultado da subquery que retorna
    o nome do autor cujo campo identificador tenha valor igual a <code>1</code>. Essa atualização
    será feita somente no registro onde o campo identificar tenha valor igual a <code>2</code>.
  </p>

  <p>
    Veja como fica o código SQL equivalente ao exemplo anterior:
  </p>

<pre>
<code>
UPDATE books 
  SET price = ?, 
  note = (SELECT name FROM authors WHERE id = ?) 
  WHERE id = ?
</code>
</pre>
  </section>

  <section>
    <h3 id="3.3">Removendo registros</h3>

    <p>O processo de remover registros de uma tabela é muito simples. Veja como funciona:</p>

<pre>
<code>
$rowCount = DataB::delete('books')
  ->exec()
  ->rows();
</code>
</pre>

  <p>
    No trecho de cógido acima excluímos todos os registros da tabela <code>books</code>.
    Para definirmos filtros par alimitar quais registros deverão ser excluídos você pode usar 
    o método <code>DataB::cond()</code> para encaderar os filtros. Observe:
  </p>

<pre>
<code>
$rowCount = DataB::delete('books')
  ->cond('id')
  ->eqValue(2)
  ->exec()
  ->rows();
</code>
</pre>
  </section>

  <section>
    <h3 id="3.4">Usando transações</h3>

    <p>
      Para alterar, atualiazar ou remover registros de forma segura use o método <code>DataB::transaction()</code>
      que recebe como parâmetro uma função callback que executa uma instrução SQL dentro de uma transação 
      de banco de dados. Caso ocorra uma falha na transação SQL então tudo será desfeito (rollback).
    </p>

<pre>
<code>
$id = DataB::transaction(function() {
  return DataB::insert('name')
  ->table('categories')
  ->values('Tecnologia')
  ->exec()
  ->getLastInsertedId();
});
</code>
</pre>

<p>
  O métod <code>DataB::transaction()</code> só retorna um valor se você retornar o valor do callback.
</p>
  </section>

  <!--Fim secao modificando dados-->
</section>

<hr>

</div>
</div>
</main>

  <!--
  <script src="https://code.jquery.com/jquery-3.6.0.slim.min.js"
    integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
  -->

  <script>window.jQuery || document.write('<script src="./js/jquery.js"><\/script>')</script>

  <!-- JavaScript Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
    crossorigin="anonymous"></script>

  <script src="./js/main.js"></script>
</body>

</html>