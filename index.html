<!doctype html>
<html lang="pt-br">

<head>
  <meta charset="utf-8">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="description" content="Documentação DataB">
  <meta name="author" content="Carlos Coutinho">
  <meta name="theme-color" content="#0d6efd">
  <meta name="msapplication-navbutton-collor" content="#0d6efd">
  <meta name="apple-mobile-web-app-status-bar-style" content="#0d6efd">
  <title>Documentação DataB</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.1/font/bootstrap-icons.css">

  <link rel="stylesheet" href="./css/idea.min.css">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="./css/style.css">

  <script src="./js/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>
  <header class="container-fluid bg-primary" id="header-top">
    <div>
      <button class="btn-bar" onclick="toggleSidebar()">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <div><a id="logo" href="#">DataB</a></div>
    <div>
      <a href="https://github.com/carloskout/datab" id="link-github" target="_blank">
        DataB no Github
        <i class="bi bi-box-arrow-up-right"></i>
      </a>
    </div>
  </header>

  <!--Siderbar-->
  <aside class="sidebar" id="sidebarElem">
    <div class="sidebar-header">
      <h3>Conteúdo</h3>
    </div>
    <hr>
    <nav>
      <ul id="summary">
        <li>
          <details>
            <summary onclick="redirect(this)" data-redir="1">
              <a href="#1">1. Introdução</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#1.1">1.1. Pré-requisitos</a>
              </li>
              <li>
                <a href="#1.2">1.2. Detalhes</a>
              </li>
              <li>
                <a href="#1.3">1.3. Como instalar</a>
              </li>
              <li>
                <a href="#1.4">1.4. Configuração e exemplo de uso</a>
              </li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary onclick="redirect(this)" data-redir="2">
              <a href="#2">2. Consultas SQL</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#2.1">2.1. Recuperando resultado</a>
              </li>
              <li>
                <a href="#2.2">2.2. Consultas nativas</a>
              </li>
              <li>
                <a href="#2.3">2.3. Funções de agregação</a>
              </li>
              <li>
                <a href="#2.5">2.5. Ordenação de dados</a>
              </li>
              <li>
                <details>
                  <summary>
                    <a href="#2.6">2.6. Filtrando dados</a>
                  </summary>
                  <ul class="sublist">
                    <li>
                      <a href="#2.6.1">2.6.1. Operadores relacionais</a>
                    </li>
                    <li>
                      <details>
                        <summary>
                          <a href="#2.6.2">2.6.2. Operadores lógicos</a>
                        </summary>
                        <ul class="sublist">
                          <li>
                            <a href="#2.6.2.1">2.6.2.1. AND e OR</a>
                          </li>
                          <li>
                            <a href="#2.6.2.2">2.6.2.2. IN e NOT IN</a>
                          </li>
                          <li>
                            <a href="#2.6.2.3">2.6.2.3. BETWEEN E NOT BETWEEN</a>
                          </li>
                          <li>
                            <a href="#2.6.2.4">2.6.2.4. LIKE</a>
                          </li>
                          <li>
                            <a href="#2.6.2.5">2.6.2.5. IS NULL e IS NOT NULL</a>
                          </li>
                          <li>
                            <a href="#2.6.2.6">2.6.2.6. EXISTS e NOT EXISTS</a>
                          </li>
                        </ul>
                      </details>
                    </li>
                  </ul>
                </details>
              </li>
              <li>
                <a href="#2.7">2.7. Limitando retorno de linhas</a>
              </li>
              <li>
                <a href="#2.8">2.8. Buscando dados não duplicados</a>
              </li>
              <li>
                <a href="#2.9">2.9. Junção de tabelas</a>
              </li>
              <li>
                <a href="#2.10">2.10. Agrupando dados</a>
              </li>
              <li>
                <a href="#2.11">2.11. Union</a>
              </li>
              <li>
                <a href="#2.12">2.12. Subqueries</a>
              </li>
              <li>
                <a href="#2.13">2.12. Subexpressões</a>
              </li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary onclick="redirect(this)" data-redir="3">
              <a href="#3">3. Modificando dados</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#3.1">3.1. Inserindo registros</a>
              </li>
              <li>
                <a href="#3.2">3.2. Atualizando registros</a>
              </li>
              <li>
                <a href="#3.3">3.3. Removendo registros</a>
              </li>
              <li>
                <a href="#3.4">3.4. Usando transações</a>
              </li>
            </ul>
          </details>
        </li>
      </ul>
    </nav>
    <div id="developer">
      <span>Desenvolvido por Carlos Coutinho</span> <br>
      <span>coutinhoco@outlook.com</span>
    </div>
  </aside>

  <main class="content" id="contentElem">
    <div class="row">
      <div class="col-md-9">

        <section>
          <h1 id="1">Introdução</h1>
          <p>
            DataB é uma library PHP que facilita a criação e execução de instruções SQL usando PDO (PHP Data Object).
          </p>

          <p>
            <strong>OBSERVAÇÃO:</strong> DataB não é uma ferramenta ORM.
          </p>

          <section>
            <h3 id="1.1">Pré-requisitos</h3>
            <p>
              Para usar DataB é necessário ter conhecimento prévio da linguagem PHP e SQL.
            </p>
          </section>

          <section>
            <h3 id="1.2">Detalhes</h3>
            <p>
              Bancos de dados suportados: <b>MYSQL</b> e <b>SQL Server</b><br>
              Versão atual da library: <b>2.0.0</b> <br>
              Licença: <b>MIT</b>
            </p>
          </section>

          <section>
            <h3 id="1.3">Como instalar</h3>
            <p>
              DataB pode ser instalada através do Composer, que é gerenciador de pacotes
              para a linguagem PHP. Basta executar o comando: <code>composer require kout/datab</code>
            </p>
            <p>
              Instalado? Ótimo! Agora você está pronto para dá os primeiros passos
              com DataB através de exemplos práticos</a>.
            </p>
          </section>

          <section>
            <h3 id="1.4">Configuração e exemplo de uso</h3>
            <p>
              Antes de comerçar a criar e executar instruções SQL, primeiro você deve
              informar para DataB uma conexão com Banco de Dados existente:
            </p>
          </section>

          <div class="code">
            $pdo = new \PDO('mysql:dbname=datab_test;host=localhost', 'root', 'root');
            $st = DB::getStatement($pdo);
          </div>

          <p>Prontinho! Agora você já pode começar a criar e executar instruções SQL. Veja como é fácil:</p>

          <div class="code">
            $result = $st->get('books')->list();
          </div>

          <p>
            O trecho de código acima retorna um array indexado com todos
            os registros da tabela <code>books</code>.
          </p>

          <p>
            Para obter a instrução SQL correspondente ao código acima basta executar
            o método <code>sql()</code> em vez do método <code>list()</code>:
          </p>

          <div class="code">
            $sql = $st->get('books')->sql();
          </div>
        </section>

        <hr>

        <section>
          <h1 id="2">Consultas SQL</h1>
          <p>
            Consultas SQL são feitas usando o método <code>get()</code> que recebe
            dois parâmetros:
          </p>

          <ul>
            <li>
              <p>Primeiro: Um ou mais nomes de tabelas que queremos consultar dados.</p>
            </li>
            <li>
              <p>
                Segundo: Um ou mais campos de tabela(s) que queremos recuperar.
              </p>
            </li>
          </ul>
          <p>
            No exemplo abaixo passamos um array como parâmetro contendo os nomes das colunas que queremos recuperar no
            resultado da query:
          </p>

          <div class="code">
            $result = $st->get('books', ['title', 'price'])->list();
          </div>

          <p>
            Se não informarmos o segundo parâmetro para o método <code>get()</code> então
            será retornado todas as colunas da tabela especificada no primeiro parâmetro.
          </p>

          <p>
            Neste outro exemplo fazemos consultas em duas tabelas distintas:
          </p>

          <div class="code">
            $result = $st->get(['authors', 'books'])->list();
          </div>

          <section>
            <h3 id="2.1">Recuperando resultado</h3>

            <p>
              Nesta seção demonstraremos todos os métodos que são usados para
              recuperar o resultado da consulta.
            </p>

            <ul>
              <li>
                <p>
                  Método <code>list()</code>: Retorna array indexado contendo todos os
                  registro retornados pela query.
                </p>

                <div class="code">
                  $result = $st->get('authors')->list();
                </div>

                <p>
                  O código acima gera a seguinte saída:
                </p>

                <div class="code">
                  array (size=5)
                  0 =>
                  array (size=2)
                  'id' => string '1' (length=1)
                  'name' => string 'Yvonne do Amaral Pereira' (length=24)
                  1 =>
                  array (size=2)
                  'id' => string '2' (length=1)
                  'name' => string 'Henrik Ibsen' (length=12)
                  2 =>
                  array (size=2)
                  'id' => string '3' (length=1)
                  'name' => string 'John Green' (length=10)
                  ...
                </div>
              </li>

              <li>
                <p>
                  Método <code>first()</code>: Retorna array associativo contendo o primeiro registro
                  retornado pela query.
                </p>
              </li>
              <li>
                <p>Método <code>last()</code>: Retorna array associativo contendo o último registro
                  retornado pela query.
                </p>
              </li>

              <li>
                <p>
                  Método <code>singleResult()</code>: Recupera valor literal retornado pela query.
                  Diferente dos outros métodos listado acima este não retorna um array.
                </p>
                <div class="code">
                  $result = $st->get('users', ['email'])->filter('id', '=', 1)->singleResult();
                  var_dump($result);

                  // A saída do método var_dump() será o valor 'foobar@datab.com'
                </div>
              </li>
              <li>
                <p>
                  Método <code>toObjects()</code>: Busca um conjunto de registros no banco de dados
                  e os retorna como instâncias de objetos da classe passada por parâmetro. Se nenhuma
                  classe for especificada o resultado da query será retornado como instâncias
                  da classe 'stdClass';
                </p>
                <div class="code">
                  class Book {}
                  $books = $st->get('books')->toObjects(Book::class);
                </div>
              </li>
              <li>
                <p>
                  Método <code>toObject()</code>: Retorna o primeiro registro da query como instância de objeto da
                  classe
                  especificada por parâmetro.
                </p>
              </li>
              <li>
                <p>
                  Método <code>lazy()</code>: Retorna o primeiro
                  registro como um objeto <code>PDORow</code> onde as variáveis desse objeto correspondem
                  aos nomes das colunas da tabela. Esse método faz o carregamento dos
                  dados conforme as propriedades do objeto <code>PDORow</code> forem acessadas.
                </p>
              </li>
            </ul>

          </section>

          <section>
            <h3 id="2.2">Executando instruções SQL nativas</h3>
            <p>
              Instrução DML:
            </p>
            <div class="code">
              $authors = $st->nativeSQL('SELECT * FROM authors');
            </div>

            <p>
              Instrução DDL:
            </p>

            <div class="code">
              $rowCount = $st->nativeSQL('ALTER TABLE categories ADD COLUMN parent INT');
            </div>
          </section>

          <section>
            <h3 id="2.3">Executando funções do banco de dados</h3>

            <p>
              Contando quantos registros existem na tabela <code>users</code>
            </p>
            <div class="code">
              $count = $st->get('users')->count('*')->singleResult();
            </div>

            <p>
              Neste outro exemplo contamos quantos livros foram publicados por
              cada autor:
            </p>

            <div class="code">
              $result = $st->get('books', ['authors.name'])
              ->count('*')
              ->innerJoin('authors', 'books.authors_id', 'authors.id')
              ->groupBy('authors.name')
              ->list();
            </div>

            <p>Veja como fica a instrução SQL correspondente ao código acima:</p>

            <div class="code">
              SELECT authors.name, COUNT(*) FROM books
              INNER JOIN authors ON books.authors_id = authors.id
              GROUP BY authors.name
            </div>

            <p>As demais funções de agregação implementadas em DataB são listadas abaixo:</p>

            <ul>
              <li>
                <code>min()</code> - Busca pelo menor valor dentre um conjuntos de valores.
              </li>
              <li>
                <code>max()</code> - Busca pelo maior valor dentre um conjuntos de valores.
              </li>
              <li>
                <code>avg()</code> - Busca pela média aritmética dentre um conjuntos de valores.
              </li>
              <li>
                <code>sum()</code> - Busca pela soma total dentre um conjuntos de valores.
              </li>
            </ul>

            <p>
              <strong>Observe</strong>: DataB não implementa todas as funções disponíveis nos bancos de dados
              suportados, contanto, é possível executar qualquer função por meio de chamada ao nome da função como se
              fosse um método implementado. Para que a inclusão da função solicitada seja adicionada
              na query, DataB faz uso do método mágico <code>_call()</code>.
            </p>

            <p>
              Veja no exemplo abaixo onde fazemos chamada à função de banco de dados <code>CONCAT</code>:
            </p>

            <div class="code">
              $result = $st->get('books')->concat('title', "'| R$ '", 'price')->list();
            </div>

            <p>
              Se a função que você quer executar for composta por mais de uma palavra onde exista
              o caracter <code>underline</code> para fazer a divisão entre as palavras, então nesse
              caso você deverá chamar a função removendo o caracter <code>underline</code>
              e juntando as palavras usando o estilo camel case. Por exemplo, para a função
              <code>DATE_FORMAT()</code> presente no banco de dados <code>MYSQL</code> você
              deverá invocá-la da seguinte forma: <code>dateFormat()</code>. Observe no trecho de código
              abaixo:
            </p>

            <div class="code">
              $result = $st->get('articles')->dateFormat('created_at', "'%d/%m/%Y'")->list();
            </div>

            <p>
              Veja como fica a instrução SQL correspondente ao código acima:
            </p>

            <div class="code">
              SELECT DATE_FORMAT(updated_at, '%d/%m/%Y') FROM articles
            </div>
          </section>

          <section>
            <h3 id="2.5">Ordenação de dados</h3>

            <p>Ordenação ascendente:</p>

            <div class="code">
              $result = $st->get('authors')->orderByAsc('name')->list();
            </div>

            <p>Ordenação descendente:</p>

            <div class="code">
              $result = $st->get('categories')->orderByDesc('name')->list();
            </div>

            <p>Ordenação por mais de uma coluna:</p>

            <div class="code">
              $result = $st->get('articles')->orderByAsc('title', 'created_at')->list();
            </div>
          </section>

          <section>
            <h3 id="2.6">Filtrando Dados</h3>

            <p>
              Para adicionar filtros à instrução SQL DataB disponibiliza o método <code>filter()</code>,
              que é usado para criar predicados, e também outros métodos como por exemplo <code>eqValue(),</code> que é
              usado para adicionar restrições de igualdade.
            </p>

            <p>
              Observe no trecho de código abaixo no qual buscamos por todos os registros da tabela
              <code>books</code> onde o preço tem que ser igual a <code>29.99</code>:
            </p>

            <div class="code">
              $result = $st->get('books')->filter('price', '=', 29.99)->list();
            </div>

            <p>Abaixo ilustramos a instrução SQL equivalente ao trecho de código acima:</p>

            <div class="code">
              SELECT * FROM books WHERE price = :col_1
            </div>

            <p>
              Por padrão, toda entrada de dados para a instrução SQL é convertida para
              <code>Named Placeholders</code> por motivos de segurança para evitar SQL injection, como visto
              no exemplo anterior onde a coluna <code>price</code> é igual a <code>:col_1</code>.
            </p>

            <p>
              Em alguns casos tavez você queira especificar <code>Named Placeholders</code> como entrada
              para a instrução SQL em vez de passar os dados literais. Neste caso, é necessário passar
              um array associativo contendo os dados de entrada para a instrução SQL. Observe:
            </p>

            <div class="code">
              $data = array('email' => 'foo@bar.com')
              $result = $st->get('users')->filter('email', '=', ':email')->list($data);
            </div>

            <p>
              O array de dados deverá ser passado como parâmetro para os
              <a href="#2.1">métodos que recuperam o resultado
                da consulta</a>.
            </p>

            <p>
              DataB não trabalha com <code>Mask Placeholders</code>, então evite usá-lo.
            </p>

            <section>
              <h4 id="2.6.1">Operadores relacionais</h4>

              <p>
                Existem duas maneiras de trabalharmos com operadores relacionais com DataB, a primeira
                é usando o método <code>filter()</code> e a segunda é usando um dos seguintes métodos
                listados abaixo:
              </p>

              <ul>
                <li>
                  <code>eqValue()</code>, <code>eqColumn()</code> (=)
                </li>
                <li>
                  <code>neValue()</code>, <code>neColumn()</code> (!=)
                </li>
                <li>
                  <code>ltValue()</code>, <code>ltColumn()</code> (&lt;)
                </li>
                <li>
                  <code>gtValue()</code>, <code>gtColumn()</code> (&gt;)
                </li>
                <li>
                  <code>leValue()</code>, <code>leColumn()</code> (&lt;=)
                </li>
                <li>
                  <code>geValue()</code>, <code>geColumn()</code> (&gt;=)
                </li>
              </ul>

              <p>
                Usando <code>filter()</code>:
              </p>

              <div class="code">
                $result = $st->get('users')->filter('email', '=', 'foo@bar.com')->list();
              </div>

              <p>
                Usando métodos específicos:
              </p>

              <div class="code">
                $result = $st->get('users')->filter('email')->eqValue('foo@bar.com')->list();
              </div>

            </section>

            <section>
              <h4 id="2.6.2">Operadores lógicos</h4>

              <section>
                <h5 id="2.6.2.1">AND e OR</h5>

                <p>
                  Use os métodos <code>and()</code> e <code>or()</code> para fazer encadeamento de expressões
                  lógicas. Observe:
                </p>

                <div class="code">
                  $result = $st->get('users')->filter('id', '>', 2)
                  ->and('email', '=', 'foo@bar.com')
                  ->or('email', '=', 'bar@foo.com')
                  ->list();
                </div>

                <p>
                  No exemplo a seguir criamos a mesma expressão lógica acima só que dessa vez usamos
                  os métodos específicos para fazermos comparações:
                </p>

                <div class="code">
                  $result = $st->get('users')->filter('id')->gtValue(2)
                  ->and('email')->eqValue('foo@bar.com')
                  ->or('email')->eqValue('bar@foo.com')
                  ->list();
                </div>

                <p>Abaixo ilustramos a instrução SQL equivalente aos dois exemplos acima:</p>

                <div class="code">
                  SELECT * FROM users WHERE id > :col_1 AND email = :col_2 OR email = :col_3
                </div>
              </section>

              <section>
                <h5 id="2.6.2.2">IN e NOT IN</h5>

                <p>
                  Os operadores <code>IN</code> e <code>NOT IN</code> podem ser adicionados à query
                  através do método <code>filter()</code> ou através dos métodos <code>in()</code>
                  e <code>notIn()</code>.
                </p>

                <p>
                  Dentro do método <code>filter()</code> o operador <code>IN</code> corresponde ao sinal
                  <code>-></code>, enquanto o operador <code>NOT IN</code> corresponde ao sinal
                  <code>!-></code>. Veja como funciona:
                </p>

                <div class="code">
                  // Operador IN (->)
                  $result = $st->get('users')->filter('id', '->', array(1,2,3,4))->list();
                </div>

                <p>
                  No trecho de código abaixo demonstramos o mesmo exemplo acima só que
                  usando o método <code>in()</code>:
                </p>

                <div class="code">
                  $result = $st->get('users')->filter('id')->in(1, 2, 3, 4)->list();
                </div>

                <p>Os dois exemplos acima gera a mesma instrução SQL:</p>

                <div class="code">
                  SELECT * FROM users WHERE id IN (:col_1, :col_2, :col_3, :col_4)
                </div>

                <p>
                  Os métodos <code>in()</code> e <code>notIn()</code> recebem como parâmetro
                  tanto um array de dados quanto um conjunto de valores separados por vírgulas.
                </p>

                <p>
                  Lembrando que você pode também usar <code>Named Placeholders</code> tanto no método
                  <code>filter()</code> quanto nos métodos <code>in()</code> e <code>notIn()</code>:
                </p>

                <div class="code">
                  $result = $st->get('users')->filter('id', '!->', array(':id1', ':id2'))
                  ->list(array('id1' => 1, 'id2' => 2));
                </div>
              </section>

              <section>
                <h5 id="2.6.2.3">BETWEEN e NOT BETWEEN</h5>

                <p>
                  Os operadores <code>BETWEEN</code> e <code>NOT BETWEEN</code> podem ser adicionados à query
                  através do método <code>filter()</code> ou através dos métodos <code>between()</code>
                  e <code>notBetween()</code>.
                </p>

                <p>
                  Dentro do método <code>filter()</code> o operador <code>BETWEEN</code> corresponde ao sinal
                  <code>' | '</code>, enquanto o operador <code>NOT BETWEEN</code> corresponde ao sinal
                  <code>' ^| '</code>. Veja como funciona:
                </p>

                <div class="code">
                  // Usando operador BETWEEN |
                  $result = $st->get('articles')
                  ->filter('updated_at', '|', array('2022-01-01', '2022-02-01'))->list();
                </div>

                <p>
                  No código acima buscamos por todos os registros da tabela <code>articles</code>
                  que foram atualizados entre as datas <code>2022-01-01</code> a <code>2022-02-01</code>
                </p>

                <p>
                  Agora observe o mesmo exemplo acima só que desta vez usando o método <code>between()</code>:
                </p>

                <div class="code">
                  $result = $st->get('articles')
                  ->filter('updated_at')->between('2022-01-01', '2022-02-01')->list();
                </div>

                <p>
                  Tanto o método <code>filter()</code> quanto os métodos <code>between()</code> e 
                  <code>notBetween()</code> aceitam <code>Named Placeholders</code>.
                </p>

                <div class="code">
                  // Usando método filter
                  $result = $st->get('articles')
                  ->filter('updated_at', '|', array(':date1', ':date2'))
                  ->list(array('date1' => '2022-01-01', 'date2' => '2022-02-01'));

                  // Usando método notBetween
                  $result = $st->get('articles')
                  ->filter('updated_at')->between(':date1', ':date2')
                  ->list(array('date1' => '2022-01-01', 'date2' => '2022-02-01'));
                </div>
              </section>

              <section>
                <h5 id="2.6.2.4">LIKE</h5>

                <p>
                  Além do método <code>filter()</code> DataB disponibiliza três métodos para se trabalhar com o operador <code>LIKE</code>:
                </p>

                <ul>
                  <li>
                    <code>startsWith()</code> - Busca por um valor que começa com um padrão.
                  </li>
                  <li>
                    <code>contains()</code> - Busca por um valor que contêm um padrão.
                  </li>
                  <li>
                    <code>endsWith()</code> - Busca por um valor que termina com um padrão.
                  </li>
                </ul>

                <p>
                  Se você decidir usar somente o método <code>filter()</code> para incluír o 
                  operador <code>LIKE</code> à instrução SQL, então é necessário usar um dos 
                  seguintes caracteres para construir o padrão de busca:
                </p>

                <ul>
                  <li>
                    <code>'^'</code> - Busca por um valor que começa com um padrão.
                  </li>
                  <li>
                    <code>'.'</code> - Busca por um valor que contêm um padrão.
                  </li>
                  <li>
                    <code>'$'</code> - Busca por um valor que termina com um padrão.
                  </li>
                </ul>

                <p>
                  A seguir demonstramos o uso do método <code>filter()</code> para buscar somente
                  os registros da tabela <code>categories</code> onde o nome inicia com a letra <code>R</code>:
                </p>

                <div class="code">
                  $result = $st->get('categories')->filter('name', '^', 'R')->list();
                </div>

                <p>
                  Veja o mesmo exemplo acima só que usando o método <code>startsWith()</code>:
                </p>

                <div class="code">
                  $result = $st->get('categories')->filter('name')->startsWith('R')->list();
                </div>

                <p>
                  Agora observe no exemplo abaixo como usar <code>Named Placeholders</code> com 
                  o operador <code>LIKE</code>:
                </p>

                <div class="code">
                  // Retorna todas as categorias cujo nome termina com 'de'
                  $result = $st->get('categories')->filter('name', '$', ':pattern')
                  ->list(['pattern' => '%de']);
                </div>
              </section>

              <section>
                <h5 id="2.6.2.5">IS NULL e IS NOT NULL</h5>

                <div class="code">
                  //IS NULL
                  $result = $st->get('categories')->filter('parent')->isNull()->list();

                  // IS NOT NULL
                  $result = $st->get('categories')->filter('parent')->isNotNull()->list();
                </div>
              </section>

              <section>
                <h5 id="2.6.2.6">EXISTS e NOT EXISTS</h5>
                <p>
                  DataB disponibiliza os métodos <code>exists()</code> e <code>notExists()</code>
                  os quais recebem como parâmetro uma função <code>callback</code>
                  na qual montamos a subquery.
                </p>

                <p>
                  No trecho de código abaixo demonstramos como recuperar todos os autores que tenham livros publicados entre os anos de
                  <code>2000</code> e <code>2019</code>.
                </p>

                <div class="code">
                  $result = $st->get('authors')
                  ->exists(function($query) {
                    $query->get('books')
                    ->filter('published', '|', [2000, 2019])
                    ->and('authors.id', '=', '*books.authors_id');
                  })
                  ->list();
                </div>

                <p>
                  A instrução SQL correspondente ao exemplo anterior fica da seguinte forma:
                </p>

                <div class="code">
                  SELECT * FROM authors WHERE 
                  EXISTS (SELECT * FROM books WHERE published BETWEEN :col_1 AND :col_2 AND authors.id = books.authors_id)
                </div>

                <p>
                  <strong>OBSERVAÇÃO:</strong> Ao se comparar duas colunas usando os métodos 
                  <code>filter()</code>, <code>and()</code>, <code>or()</code> e <code>subexpr()</code> a última coluna deverá ser precedida pelo caracter <code>'*'</code>. Isso
                  é necessário para que a ultima coluna não seja interpretada como um valor literal da primeira coluna.
                </p>

                <p>
                  Por exemplo, no trecho de código a seguir fazemos comparação entre duas colunas:
                </p>

                <div class="code">
                  $result = $st->get(['articles', 'authors'])
                    ->filter('articles.authors_id', '=', '*authors.id')->list();
                  
                  /*Código SQL: 
                  SELECT * FROM articles, authors WHERE articles.authors_id = authors.id*/
                </div>

                <p>
                  Agora neste outro exemplo fazemos comparação entre a coluna e seu respectivo valor:
                </p>

                <div class="code">
                  $result = $st->get('users')
                    ->filter('email', '=', 'foo@bar.com')->list();
                  
                  /*Código SQL: 
                  SELECT * FROM users WHERE email = :col_1*/
                </div>

              </section>

              <!--fim secao operadores logicos-->
            </section>

            <!--Fim secao filtrando dados-->
          </section>

          <section>
            <h3 id="2.7">Limitando retorno de linhas</h3>

            <p>
              Para este propósito DataB disponibiliza os seguintes métodos:
              <code>offset()</code> e <code>fetch()</code>.
            </p>

            <p>
              Em banco de dados <code>SQL Server</code> é necessário usar a ordenação de dados
              antes de limitar o retorno de linhas. No <code>MYSQL</code> não é preciso.
            </p>

            <p>
              Veja como funciona usando <code>SQL Server</code>:
            </p>

            <div class="code">
              // Recuperando todos os registros a partir da décima linha
              $result = $st->get('articles')->orderByAsc('title')->offset(10)->list();

              // Recuperando os primeiros 10 registros
              $result = $st->get('articles')->orderByAsc('title')->fetch(10)->list();

              // Recuperando os primeiros 20 registros a partir da décima linha
              $result = $st->get('articles')->orderByAsc('title')->offset(10)->fetch(20)->list();
            </div>

            <p>
              Usando <code>MYSQL</code>:
            </p>

            <div class="code">
              /* Por padrão, se não for especificado o fetch, são retornados somente 1000 registros a partir do offset especificado.*/

              // Recuperando 1000 registros a partir da décima linha.
              $result = $st->get('articles')->offset(10)->list();

              // Recuperando os primeiros 10 registros
              $result = $st->get('articles')->fetch(10)->list();

              // Recuperando 20 registros a partir da décima linha.
              $result = $st->get('articles')->offset(10)->fetch(20)->list();
            </div>
          </section>

          <section>
            <h3 id="2.8">Buscando dados não duplicados</h3>
            
            <p>
              DataB disponibiliza o método <code>distinct()</code> o qual recebe como parâmetro tanto um array quanto um conjunto de colunas separadas por vírgulas.
            </p>

            <div class="code">
              $result = $st->get('employees')->distinct('lastname')->list();

              // Usando mais de uma coluna
              $result = $st->get('employees')->distinct('lastname', 'city')->list();
            </div>

          </section>

          <section>
            <h3 id="2.9"> Junção de tabelas</h3>
            <p>
              Nesta seção demonstramos como fazer junção de tabelas com DataB. No exemplo abaixo,
              usamos o método <code>filter()</code> para criar a junção entre
              as tabelas <code>authors</code> e <code>books</code>:
            </p>

            <div class="code">
              $result = $st->get(['books', 'authors'])
                ->filter('books.authors_id', '=', '*authors.id')->list();

              //Outra maneira usando filter
              $result = $st->get(['books', 'authors'])
                ->filter('books.authors_id')->eqColumn('authors.id')->list();
            </div>

            <p>
              Usando <code>inner join</code>:
            </p>

            <div class="code">
              $result = $st->get('books')
                ->innerJoin('authors', 'books.authors_id', 'authors.id')->list();
            </div>

            <p>
              Ok. Os demais métodos disponíveis em DataB para criar junções de tabelas são estes:
              <code>leftJoin()</code>, <code>rightJoin()</code>, <code>crossJoin()</code> e
              <code>fullJoin()</code>.
            </p>
          </section>

          <section>
            <h3 id="2.10">Agrupando dados</h3>

            <p>
              Para agrupar dados use o método <code>groupBy()</code> e para definir condições
              de agrupamento use o método <code>having()</code>.
            </p>

            <p>
              A seguir demonstramos uma query na qual buscamos todos os registros da tabela
              funcionários agrupando por departamentos:
            </p>

            <div class="code">
              $result = $st->get('employees', ['employees.name', 'departaments.name'])
              ->innerJoin('departaments', 'employees.dep_id', 'departaments.id')
              ->groupBy('departaments.name')->list();
            </div>

            <p>Instrução SQL:</p>

            <div class="code">
              SELECT employees.name, departaments.name FROM employees 
              INNER JOIN departaments ON employees.dep_id = departaments.id 
              GROUP BY departaments.name
            </div>

            <p>
              Se você já está familiarizado com o uso do método <code>filter()</code> então não terá
              nenhum problema em usar o método <code>Data::having()</code> pois funciona da mesma maneira.
            </p>
          </section>

          <section>
            <h3 id="2.11">Union</h3>

            <p>
              Para unir dois ou mais conjuntos de resultados DataB disponibiliza os métodos
              <code>union()</code> e <code>unionAll()</code> que recebem como parâmetro uma <code>função callback</code> na qual montamos uma <code>subquery</code>. Observe:
            </p>

            <div class="code">
              //Combinando nomes de funcionários e clientes
              $result = $st->get('employees', ['name'])
              ->union(function($query) {   
                $query->get('customers', ['name']);
               })->list();
            </div>
          </section>

          <section>
            <h3 id="2.12">Subqueries</h3>

            <p>
              No ambiente de banco de dados é bastante comum o uso de subqueries para construir
              consultas SQL complexas. Pois bem, DataB fornece
              suporte a subqueries no qual usamos funções callbacks para criá-las. A maioria dos métodos em DataB
              recebem
              função callback como parâmetro tanto para se criar subqueries quanto subexpressões. A seguir
              disponibilizamos
              uma lista com todos os método que suportam subqueries:
            </p>

            <ul>
              <li>
                <code>filter()</code>
              </li>
              <li>
                <code>eqValue()</code>
              </li>
              <li>
                <code>neValue()</code>
              </li>
              <li>
                <code>ltValue()</code>
              </li>
              <li>
                <code>gtValue()</code>
              </li>
              <li>
                <code>leValue()</code>
              </li>
              <li>
                <code>geValue()</code>
              </li>
              <li>
                <code>in()</code>
              </li>
              <li>
                <code>notIn()</code>
              </li>
              <li>
                <code>exists()</code>
              </li>
              <li>
                <code>notExists()</code>
              </li>
              <li>
                <code>union()</code>
              </li>
              <li>
                <code>unionAll()</code>
              </li>
              <li>
                <code>put()</code>
              </li>
              <li><code>remove()</code></li>
            </ul>

            <p>
              Neste outro exemplo buscamos somente os registros da tabela <code>books</code> onde
              o nome da categoria começa com a letra <code>R</code>. Observe também que dentro da subquery
              usamos <code>mask placeholders</code> como entrada de parâmetro para o método
              <code>startsWith()</code>
              em vez de passar o valor literal. Fica a seu critério usar <code>mask placeholder</code>,
              <code>named placeholders</code> ou o próprio valor literal:
            </p>

            <div class="code">
              $result = select('*')
              ->table('books')
              ->cond('categories_id')
              ->eqValue(function() {
              return select('id')
              ->table('categories')
              ->cond('name')
              ->startsWith('?');
              })
              ->exec(['R%'])
              ->getAll();
            </div>

            <p>
              O código SQL correspondente ao exemplo acima é ilustrado a seguir:
            </p>

            <div class="code">
              SELECT * FROM books
              WHERE categories_id = (SELECT id FROM categories WHERE name LIKE ?)
            </div>
          </section>

          <section>
            <h3 id="2.13">Subexpressões</h3>
            <p>
              Subexpressões são criadas passando uma função callback como parâmetro para os métodos
              <code>and()</code> e <code>or()</code>. Observe:
            </p>

            <div class="code">
              $result = select('*')
              ->table('books')
              ->cond('categories_id')
              ->eqValue(1) // Romance
              ->and(function() {
              return column('published')
              ->eqValue(2019)
              ->or('price')
              ->leValue(40.00);
              })
              ->exec()
              ->getAll();
            </div>

            <p>
              Observe que passamos uma função callback para o método <code>and()</code>. Dentro dessa função
              criamos e retornamos a subexpressão.
            </p>

            <p>
              Veja como fica a instrução SQL referente ao exemplo anterior:
            </p>

            <div class="code">
              SELECT * FROM books
              WHERE categories_id = ?
              AND (published = ? OR price &lt;= ?)
            </div>
          </section>
          <!--Fim secao consultas-->
        </section>

        <section>
          <h1 id="3">Modificando dados</h1>

          <p>
            Nesta seção você aprenderá como inserir, atualizar e remover registros do banco de dados
            usando <code>DataB</code>.
          </p>

          <section>
            <h3 id="3.1">Inserindo registros</h3>

            <p>
              Para inserir novos registros em uma tabela com DataB muito fácil, basta passar
              para o método <code>insert()</code> a relação de campos da tabela que
              você quer inserir. Essa relação pode ser tanto um <code>array</code> quanto uma lista
              de <code>strings</code>.
            </p>

            <p>
              Veja no exemplo abaixo no qual inserimos um registro na tabela <code>books</code>:
            </p>

            <div class="code">
              $id = insert('title', 'price', 'published', 'categories_id', 'authors_id')
              ->table('books')
              ->values('Cinquenta Tons de Cinza', 24.95, 2011, 1, 1)
              ->exec()
              ->getLastInsertedId();
            </div>

            <p>
              Agora observe o mesmo exemplo só que passando um array como parâmetro para o método
              <code>insert()</code>:
            </p>

            <div class="code">
              $columns = ['title', 'price', 'published', 'categories_id', 'authors_id'];

              $id = insert($columns)
              ->table('books')
              ->values('Cinquenta Tons de Cinza', 24.95, 2011, 1, 1)
              ->exec()
              ->getLastInsertedId();
            </div>

            <p>
              No exemplos acima passamos os valores literais para o método <code>values()</code>, mas
              você pode usar também <code>mask placeholders</code> ou <code>named placeholders</code>.
            </p>

            <p>
              Usando mask placeholders:
            </p>

            <div class="code">
              $data = ['Cinquenta Tons de Cinza', 24.95, 2011, 1, 1];

              $id = insert('title', 'price', 'published', 'categories_id', 'authors_id')
              ->table('books')
              ->values('?', '?', '?', '?', '?')
              ->exec($data)
              ->getLastInsertedId();
            </div>

            <p>
              Usando named placeholders:
            </p>

            <div class="code">
              $data = [
              'title' => 'Cinquenta Tons de Cinza',
              'price' => 24.95,
              'published' => 2011,
              'cat_id' => 1,
              'authors_id' => 1
              ];

              $id = insert('title', 'price', 'published', 'categories_id', 'authors_id')
              ->table('books')
              ->values(':title', ':price', ':published', ':cat_id', ':authors_id')
              ->exec($data)
              ->getLastInsertedId();
            </div>

            <p>
              No exemplo abaixo mostramos como inserir vários registros ao mesmo tempo:</code>
            </p>

            <div class="code">
              $id = insert('name')
              ->table('authors')
              ->values('Carlos Coutinho')
              ->values('Junior César')
              ->values('Cláudio Borges')
              ->exec()
              ->getLastInsertedId();
            </div>

            <p>
              Você pode também inserir um novo registro usando dados de uma consulta. Neste caso, devemos passar
              para o método <code>values()</code> uma função callback que retorna uma subquery.
              Observe:
            </p>

            <div class="code">
              $id = insert('name')
              ->table('authors')
              ->values(function() {
              return select('name')
              ->table('authors')
              ->cond('id')
              ->eqValue(2);
              })
              ->exec()
              ->getLastInsertedId();
            </div>

            <p>
              No exemplo acima buscamos pelo registro da tabela <code>authors</code> cujo campo identificador
              <code>(id)</code> seja igual a <code>2</code>, entao usamos o resultado dessa query para inserir um novo
              registro no banco de dados
            </p>

            <p>
              Se você não especificar um filtro para limitar a quantidade de registros retornados pela query então todos
              os registros retornados serao inseridos no banco de dados.
            </p>
          </section>

          <section>
            <h3 id="3.2">Atualizando registros</h3>

            <p>
              Para fazer atualizações de registros em uma tabela específca devemos usar o método
              <code>update()</code> no qual passampos por parâmetro a lista de colunas que
              queremos atualizar; em seguida usamos o método <code>table()</code> para
              definirmos em qual tabela ocorrerá as alterações; na sequência invocamos o método
              <code>set()</code> no qual informamaos um conjunto de dados correspondentes à
              lista de campos que queremos atualizar.
            </p>

            <p>
              No trecho de código abaixo atualizamos o registro da tabela <code>books</code>
              onde o campo identificador <code>id</code> seja igual a <code>1</code>:
            </p>

            <div class="code">
              $rowCount = update('price', 'note')
              ->table('books')
              ->set(65.98, 'Este livro foi atualizado')
              ->cond('id')
              ->eqValue(1)
              ->exec()
              ->rows();
            </div>

            <p>
              O método <code>rows()</code> retorna o número de linhas afetadas pela query.
            </p>

            <p>
              No exemplo acima passamos como parâmetro para o método <code>set()</code> os valores
              literais, mas você pode usar também <code>mask placeholders</code> ou <code>named placeholders</code>.
            </p>

            <p>
              No exemplo abaixo demonstramos o mesmo exemplo só que usando <code>mask placeholders</code> e
              passando a lista de campos para o método <code>update()</code> como um array:
            </p>

            <div class="code">
              $rowCount = update(['price', 'note'])
              ->table('books')
              ->set('?', '?')
              ->cond('id')
              ->eqValue('?')
              ->exec([68.98, 'Este livro foi atualizado', 1])
              ->rows();
            </div>

            <p>
              Neste outro exemplo demonstramos o uso de <code>named placeholders</code>:
            </p>

            <div class="code">
              $rowCount = update(['price', 'note'])
              ->table('books')
              ->set(':price', ':note')
              ->cond('id')
              ->eqValue(':id')
              ->exec([
              'price' => 68.98,
              'note' => 'Este livro foi atualizado',
              'id' => 1])
              ->rows();
            </div>

            <p>
              Agora vamos mostrar como atualizar coluna usando o resultado de uma <code>subquery</code>:
            </p>

            <div class="code">
              $rowCount = update('price', 'note')
              ->table('books')
              ->set(64.95,
              function() {
              return select('name')
              ->table('authors')
              ->cond('id')
              ->eqValue(1);
              }
              )
              ->cond('id')
              ->eqValue(2)
              ->exec()
              ->rows();
            </div>

            <p>
              No exemplo acima atualizamos o valor da coluna <code>price</code> para <code>64.95</code>
              e para a coluna <code>note</code> definimos como valor o resultado da subquery que retorna
              o nome do autor cujo campo identificador tenha valor igual a <code>1</code>. Essa atualização
              será feita somente no registro onde o campo identificar tenha valor igual a <code>2</code>.
            </p>

            <p>
              Veja como fica o código SQL equivalente ao exemplo anterior:
            </p>

            <div class="code">
              UPDATE books
              SET price = ?,
              note = (SELECT name FROM authors WHERE id = ?)
              WHERE id = ?
            </div>
          </section>

          <section>
            <h3 id="3.3">Removendo registros</h3>

            <p>O processo de remover registros de uma tabela é muito simples. Veja como funciona:</p>

            <div class="code">
              $rowCount = delete('books')
              ->exec()
              ->rows();
            </div>

            <p>
              No trecho de cógido acima excluímos todos os registros da tabela <code>books</code>.
              Para definirmos filtros par alimitar quais registros deverão ser excluídos você pode usar
              o método <code>cond()</code> para encaderar os filtros. Observe:
            </p>

            <div class="code">
              $rowCount = delete('books')
              ->cond('id')
              ->eqValue(2)
              ->exec()
              ->rows();
            </div>
          </section>

          <section>
            <h3 id="3.4">Usando transações</h3>

            <p>
              Para alterar, atualiazar ou remover registros de forma segura use o método
              <code>transaction()</code>
              que recebe como parâmetro uma função callback que executa uma instrução SQL dentro de uma transação
              de banco de dados. Caso ocorra uma falha na transação SQL então tudo será desfeito (rollback).
            </p>

            <div class="code">
              $id = transaction(function() {
              return insert('name')
              ->table('categories')
              ->values('Tecnologia')
              ->exec()
              ->getLastInsertedId();
              });
            </div>

            <p>
              O métod <code>transaction()</code> só retorna um valor se você retornar o valor do callback.
            </p>
          </section>

          <!--Fim secao modificando dados-->
        </section>

        <hr>

      </div>
    </div>
  </main>

  <script>
    document.querySelectorAll('div.code').forEach(el => {
      hljs.highlightElement(el);
    });
    function toggleSidebar() {
      document.querySelector('#sidebarElem').classList.toggle('toggle');
      document.querySelector('#contentElem').classList.toggle('toggle');
    }
    function redirect(e) {
      location.href = '#' + e.dataset.redir;
    }
  </script>
  <!--
  <script src="https://code.jquery.com/jquery-3.6.0.slim.min.js"
    integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
  -->

  <script>window.jQuery || document.write('<script src="./js/jquery.js"><\/script>')</script>

  <!-- JavaScript Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
    crossorigin="anonymous"></script>
</body>

</html>