<!doctype html>
<html lang="pt-br">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Documentação DataB">
  <meta name="author" content="Carlos Coutinho">
  <meta name="theme-color" content="#0d6efd">
  <meta name="msapplication-navbutton-collor" content="#0d6efd">
  <meta name="apple-mobile-web-app-status-bar-style" content="#0d6efd">
  <title>Documentação DataB</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.1/font/bootstrap-icons.css">

  <link rel="stylesheet" href="./css/idea.min.css">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="./css/style.css">

  <script src="./js/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>
  <header class="container-fluid bg-primary" id="header-top">
    <div>
      <button class="btn-bar" onclick="toggleSidebar()">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <div><a id="logo" href="#">DataB</a></div>
    <div>
      <a href="https://github.com/carloskout/datab" id="link-github" target="_blank">
        DataB no Github
        <i class="bi bi-box-arrow-up-right"></i>
      </a>
    </div>
  </header>

  <!--Siderbar-->
  <aside class="sidebar" id="sidebarElem">
    <div class="sidebar-header">
      <h3>Conteúdo</h3>
    </div>
    <hr>
    <nav>
      <ul>
        <li>
          <details>
            <summary>
              <a href="#1">1. Introdução</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#1.1">1.1. Pré-requisitos</a>
              </li>
              <li>
                <a href="#1.2">1.2. Detalhes</a>
              </li>
              <li>
                <a href="#1.3">1.3. Como instalar</a>
              </li>
              <li>
                <a href="#1.4">1.4. Configuração e exemplo de uso</a>
              </li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary>
              <a href="#2">2. Consultas SQL</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#2.1">2.1. Recuperando resultado</a>
              </li>
              <li>
                <a href="#2.2">2.2. Consultas nativas</a>
              </li>
              <li>
                <a href="#2.3">2.3. Funções de agregação</a>
              </li>
              <li>
                <a href="#2.5">2.5. Ordenação de dados</a>
              </li>
              <li>
                <details>
                  <summary>
                    <a href="#2.6">2.6. Filtrando dados</a>
                  </summary>
                  <ul class="sublist">
                    <li>
                      <a href="#2.6.1">2.6.1. Operadores relacionais</a>
                    </li>
                    <li>
                      <details>
                        <summary>
                          <a href="#2.6.2">2.6.2. Operadores lógicos</a>
                        </summary>
                        <ul class="sublist">
                          <li>
                            <a href="#2.6.2.1">2.6.2.1. AND e OR</a>
                          </li>
                          <li>
                            <a href="#2.6.2.2">2.6.2.2. IN e NOT IN</a>
                          </li>
                          <li>
                            <a href="#2.6.2.3">2.6.2.3. BETWEEN E NOT BETWEEN</a>
                          </li>
                          <li>
                            <a href="#2.6.2.4">2.6.2.4. LIKE</a>
                          </li>
                          <li>
                            <a href="#2.6.2.5">2.6.2.5. IS NULL e IS NOT NULL</a>
                          </li>
                          <li>
                            <a href="#2.6.2.6">2.6.2.6. EXISTS e NOT EXISTS</a>
                          </li>
                        </ul>
                      </details>
                    </li>
                  </ul>
                </details>
              </li>
              <li>
                <a href="#2.7">2.7. Limitando retorno de linhas</a>
              </li>
              <li>
                <a href="#2.8">2.8. Buscando dados não duplicados</a>
              </li>
              <li>
                <a href="#2.9">2.9. Junção de tabelas</a>
              </li>
              <li>
                <a href="#2.10">2.10. Agrupando dados</a>
              </li>
              <li>
                <a href="#2.11">2.11. Union</a>
              </li>
              <li>
                <a href="#2.12">2.12. Subqueries</a>
              </li>
              <li>
                <a href="#2.13">2.12. Subexpressões</a>
              </li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary>
              <a href="#3">3. Modificando dados</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#3.1">3.1. Inserindo registros</a>
              </li>
              <li>
                <a href="#3.2">3.2. Atualizando registros</a>
              </li>
              <li>
                <a href="#3.3">3.3. Removendo registros</a>
              </li>
              <li>
                <a href="#3.4">3.4. Usando transações</a>
              </li>
            </ul>
          </details>
        </li>
      </ul>
    </nav>
    <hr>
    <div id="developer">
      <span>Desenvolvido por Carlos Coutinho</span> <br>
      <span>coutinhoco@outlook.com</span>
    </div>
  </aside>

  <main class="content" id="contentElem">
    <div class="row">
      <div class="col-md-9">

        <section>
          <h1 id="1">Introdução</h1>
          <p>
            DataB é uma library PHP que facilita a criação e execução de instruções SQL usando PDO (PHP Data Object).
          </p>

          <p>
            <strong>OBSERVAÇÃO:</strong> DataB não é uma ferramenta ORM.
          </p>

          <section>
            <h3 id="1.1">Pré-requisitos</h3>
            <p>
              Para usar DataB é necessário ter conhecimento prévio da linguagem PHP e SQL.
            </p>
          </section>

          <section>
            <h3 id="1.2">Detalhes</h3>
            <p>
              Bancos de dados suportados: <b>MYSQL</b> e <b>SQL Server</b><br>
              Versão atual da library: <b>2.0.0</b> <br>
              Licença: <b>MIT</b>
            </p>
          </section>

          <section>
            <h3 id="1.3">Como instalar</h3>
            <p>
              DataB pode ser instalada através do Composer, que é gerenciador de pacotes
              para a linguagem PHP. Basta executar o comando: <code>composer require kout/datab</code>
            </p>
            <p>
              Instalado? Ótimo! Agora você está pronto para dá os primeiros passos
              com DataB através de exemplos práticos</a>.
            </p>
          </section>

          <section>
            <h3 id="1.4">Configuração e exemplo de uso</h3>
            <p>
              Antes de comerçar a criar e executar instruções SQL, primeiro você deve
              informar para DataB uma conexão com Banco de Dados existente:
            </p>
          </section>

          <div class="code">
            $pdo = new \PDO('mysql:dbname=datab_test;host=localhost', 'root', 'root');
            $st = DB::getStatement($pdo);
          </div>

          <p>Prontinho! Agora você já pode começar a criar e executar instruções SQL. Veja como é fácil:</p>

          <div class="code">
            $result = $st->get('books')->list();
          </div>

          <p>
            O trecho de código acima retorna um array indexado com todos
            os registros da tabela <code>books</code>.
          </p>

          <p>
            Para obter a instrução SQL correspondente ao código acima basta executar
            o método <code>sql()</code> em vez do método <code>list()</code>:
          </p>

          <div class="code">
            $sql = $st->get('books')->sql();
          </div>
        </section>

        <hr>

        <section>
          <h1 id="2">Consultas SQL</h1>
          <p>
            Consultas SQL são feitas usando o método <code>get()</code> que recebe
            dois parâmetros:
          </p>

          <ul>
            <li>
              <p>Primeiro: Um ou mais nomes de tabelas que queremos consultar dados.</p>
            </li>
            <li>
              <p>
                Segundo: Um ou mais campos de tabela(s) que queremos recuperar.
              </p>
            </li>
          </ul>
          <p>
            No exemplo abaixo passamos um array como parâmetro contendo os nomes das colunas que queremos recuperar no
            resultado da query:
          </p>

          <div class="code">
            $result = $st->get('books', ['title', 'price'])->list();
          </div>

          <p>
            Se não informarmos o segundo parâmetro para o método <code>get()</code> então
            será retornado todas as colunas da tabela especificada no primeiro parâmetro.
          </p>

          <p>
            Neste outro exemplo fazemos consultas em duas tabelas distintas:
          </p>

          <div class="code">
            $result = $st->get(['authors', 'books'])->list();
          </div>

          <section>
            <h3 id="2.1">Recuperando resultado</h3>

            <p>
              Nesta seção demonstraremos todos os métodos que são usados para
              recuperar o resultado da consulta.
            </p>

            <ul>
              <li>
                <p>
                  Método <code>list()</code>: Retorna array indexado contendo todos os
                  registro retornados pela query.
                </p>

                <div class="code">
                  $result = $st->get('authors')->list();
                </div>

                <p>
                  O código acima gera a seguinte saída:
                </p>

                <div class="code">
                  array (size=5)
                  0 =>
                  array (size=2)
                  'id' => string '1' (length=1)
                  'name' => string 'Yvonne do Amaral Pereira' (length=24)
                  1 =>
                  array (size=2)
                  'id' => string '2' (length=1)
                  'name' => string 'Henrik Ibsen' (length=12)
                  2 =>
                  array (size=2)
                  'id' => string '3' (length=1)
                  'name' => string 'John Green' (length=10)
                  ...
                </div>
              </li>

              <li>
                <p>
                  Método <code>first()</code>: Retorna array associativo contendo o primeiro registro
                  retornado pela query.
                </p>
              </li>
              <li>
                <p>Método <code>last()</code>: Retorna array associativo contendo o último registro
                  retornado pela query.
                </p>
              </li>

              <li>
                <p>
                  Método <code>singleResult()</code>: Recupera valor literal retornado pela query.
                  Diferente dos outros métodos listado acima este não retorna um array.
                </p>
                <div class="code">
                  $result = $st->get('users', ['email'])->filter('id', '=', 1)->singleResult();
                  var_dump($result);

                  // A saída do método var_dump() será o valor 'foobar@datab.com'
                </div>
              </li>
              <li>
                <p>
                  Método <code>toObjects()</code>: Busca um conjunto de registros no banco de dados
                  e os retorna como instâncias de objetos da classe passada por parâmetro. Se nenhuma
                  classe for especificada o resultado da query será retornado como instâncias
                  da classe 'stdClass';
                </p>
                <div class="code">
                  class Book {}
                  $books = $st->get('books')->toObjects(Book::class);
                </div>
              </li>
              <li>
                <p>
                  Método <code>toObject()</code>: Retorna o primeiro registro da query como instância de objeto da
                  classe
                  especificada por parâmetro.
                </p>
              </li>
              <li>
                <p>
                  Método <code>lazy()</code>: Retorna o primeiro
                  registro como um objeto <code>PDORow</code> onde as variáveis desse objeto correspondem
                  aos nomes das colunas da tabela. Esse método faz o carregamento dos
                  dados conforme as propriedades do objeto <code>PDORow</code> forem acessadas.
                </p>
              </li>
            </ul>

          </section>

          <section>
            <h3 id="2.2">Executando instruções SQL nativas</h3>
            <p>
              Instrução DML:
            </p>
            <div class="code">
              $authors = $st->nativeSQL('SELECT * FROM authors');
            </div>

            <p>
              Instrução DDL:
            </p>

            <div class="code">
              $rowCount = $st->nativeSQL('ALTER TABLE categories ADD COLUMN parent INT');
            </div>
          </section>

          <section>
            <h3 id="2.3">Executando funções do banco de dados</h3>

            <p>
              Contando quantos registros existem na tabela <code>users</code>
            </p>
            <div class="code">
              $count = $st->get('users')->count('*')->singleResult();
            </div>

            <p>
              Neste outro exemplo contamos quantos livros foram publicados por
              cada autor:
            </p>

            <div class="code">
              $result = $st->get('books', ['authors.name'])
              ->count('*')
              ->innerJoin('authors', 'books.authors_id', 'authors.id')
              ->groupBy('authors.name')
              ->list();
            </div>

            <p>Veja como fica a instrução SQL correspondente ao código acima:</p>

            <div class="code">
              SELECT authors.name, COUNT(*) FROM books
              INNER JOIN authors ON books.authors_id = authors.id
              GROUP BY authors.name
            </div>

            <p>As demais funções de agregação implementadas em DataB são listadas abaixo:</p>

            <ul>
              <li>
                <code>DataB::min()</code> - Busca pelo menor valor dentre um conjuntos de valores.
              </li>
              <li>
                <code>DataB::max()</code> - Busca pelo maior valor dentre um conjuntos de valores.
              </li>
              <li>
                <code>DataB::avg()</code> - Busca pela média aritmética dentre um conjuntos de valores.
              </li>
              <li>
                <code>DataB::sum()</code> - Busca pela soma total dentre um conjuntos de valores.
              </li>
            </ul>

            <p>
              <strong>Observe</strong>: DataB não implementa todas as funções disponíveis nos bancos de dados
              suportados, contanto, é possível executar qualquer função por meio de chamada ao nome da função como se
              fosse um método implementado. Para que a inclusão da função solicitada seja adicionada
              na query, DataB faz uso do método mágico <code>_call()</code>.
            </p>

            <p>
              Veja no exemplo abaixo onde fazemos chamada à função de banco de dados <code>CONCAT</code>:
            </p>

            <div class="code">
              $result = $st->get('books')->concat('title', "'| R$ '", 'price')->list();
            </div>

            <p>
              Se a função que você quer executar for composta por mais de uma palavra onde exista
              o caracter <code>underline</code> para fazer a divisão entre as palavras, então nesse
              caso você deverá chamar a função removendo o caracter <code>underline</code>
              e juntando as palavras usando o estilo camel case. Por exemplo, para a função
              <code>DATE_FORMAT()</code> presente no banco de dados <code>MYSQL</code> você
              deverá invocá-la da seguinte forma: <code>dateFormat()</code>. Observe no trecho de código
              abaixo:
            </p>

            <div class="code">
              $result = $st->get('articles')->dateFormat('created_at', "'%d/%m/%Y'")->list();
            </div>

            <p>
              Veja como fica a instrução SQL correspondente ao código acima:
            </p>

            <div class="code">
              SELECT DATE_FORMAT(updated_at, '%d/%m/%Y') FROM articles
            </div>
          </section>

          <section>
            <h3 id="2.5">Ordenação de dados</h3>

            <p>Ordenação ascendente:</p>

            <div class="code">
              $result = $st->get('authors')->orderByAsc('name')->list();
            </div>

            <p>Ordenação descendente:</p>

            <div class="code">
              $result = $st->get('categories')->orderByDesc('name')->list();
            </div>

            <p>Ordenação por mais de uma coluna:</p>

            <div class="code">
              $result = $st->get('articles')->orderByAsc('title', 'created_at')->list();
            </div>
          </section>

          <section>
            <h3 id="2.6">Filtrando Dados</h3>

            <p>
              Para adicionar filtros à instrução SQL DataB disponibiliza o método <code>filter()</code>,
              que é usado para criar predicados, e também outros métodos como por exemplo <code>eqValue(),</code> que é
              usado para adicionar restrições de igualdade.
            </p>

            <p>
              Observe no trecho de código abaixo no qual buscamos por todos os registros da tabela
              <code>books</code> onde o preço tem que ser igual a <code>29.99</code>:
            </p>

            <div class="code">
              $result = $st->get('books')->filter('price', '=', 29.99)->list();
            </div>

            <p>Abaixo ilustramos a instrução SQL equivalente ao trecho de código acima:</p>

            <div class="code">
              SELECT * FROM books WHERE price = :col_1
            </div>

            <p>
              Por padrão, toda entrada de dados para a instrução SQL é convertida para
              <code>Named Placeholders</code> por motivos de segurança para evitar SQL injection, como visto
              no exemplo anterior onde a coluna <code>price</code> é igual a <code>:col_1</code>.
            </p>

            <p>
              Em alguns casos tavez você queira especificar <code>Named Placeholders</code> como entrada
              para a instrução SQL em vez de passar os dados literais. Neste caso, é necessário passar
              um array associativo contendo os dados de entrada para a instrução SQL. Observe:
            </p>

            <div class="code">
              $data = array('email' => 'foo@bar.com')
              $result = $st->get('users')->filter('email', '=', ':email')->list($data);
            </div>

            <p>
              O array de dados deverá ser passado como parâmetro para os
              <a href="#2.1">métodos que recuperam o resultado
                da consulta</a>.
            </p>

            <p>
              DataB não trabalha com <code>Mask Placeholders</code>, então evite usá-lo.
            </p>

            <section>
              <h4 id="2.6.1">Operadores relacionais</h4>

              <p>
                Existem duas maneiras de trabalharmos com operadores relacionais com DataB, a primeira
                é usando o método <code>filter()</code> e a segunda é usando um dos seguintes métodos
                listados abaixo:
              </p>

              <ul>
                <li>
                  <code>eqValue()</code>, <code>eqColumn()</code> (=)
                </li>
                <li>
                  <code>neValue()</code>, <code>neColumn()</code> (!=)
                </li>
                <li>
                  <code>ltValue()</code>, <code>ltColumn()</code> (&lt;)
                </li>
                <li>
                  <code>gtValue()</code>, <code>gtColumn()</code> (&gt;)
                </li>
                <li>
                  <code>leValue()</code>, <code>leColumn()</code> (&lt;=)
                </li>
                <li>
                  <code>geValue()</code>, <code>geColumn()</code> (&gt;=)
                </li>
              </ul>

              <p>
                Usando <code>filter()</code>:
              </p>

              <div class="code">
                $result = $st->get('users')->filter('email', '=', 'foo@bar.com')->list();
              </div>

              <p>
                Usando métodos específicos:
              </p>

              <div class="code">
                $result = $st->get('users')->filter('email')->eqValue('foo@bar.com')->list();
              </div>

            </section>

            <section>
              <h4 id="2.6.2">Operadores lógicos</h4>

              <section>
                <h5 id="2.6.2.1">AND e OR</h5>

                <p>
                  Use os métodos <code>and()</code> e <code>or()</code> para fazer encadeamento de expressões
                  lógicas. Observe:
                </p>

                <div class="code">
                  $result = $st->get('users')->filter('id', '>', 2)
                  ->and('email', '=', 'foo@bar.com')
                  ->or('email', '=', 'bar@foo.com')
                  ->list();
                </div>

                <p>
                  No exemplo asseguir criamos a mesma expressão lógica acima só que dessa vez usamos
                  os métodos específicos para fazermos comparações:
                </p>

                <div class="code">
                  $result = $st->get('users')->filter('id')->gtValue(2)
                  ->and('email')->eqValue('foo@bar.com')
                  ->or('email')->eqValue('bar@foo.com')
                  ->list();
                </div>

                <p>Abaixo ilustramos a instrução SQL equivalente aos dois exemplos acima:</p>

                <div class="code">
                  SELECT * FROM users WHERE id > :col_1 AND email = :col_2 OR email = :col_3
                </div>
              </section>

              <section>
                <h5 id="2.6.2.2">IN e NOT IN</h5>

                <p>
                  Os operadores <code>IN</code> e <code>NOT IN</code> podem ser adicionados a query
                  através do método <code>filter()</code> ou através dos métodos <code>in()</code>
                  e <code>notIn()</code>.
                </p>

                <p>
                  Dentro do método <code>filter()</code> o operador <code>IN</code> corresponde ao sinal
                  <code>-></code>, enquanto o operador <code>NOT IN</code> corresponde ao sinal
                  <code>!-></code>. Veja como funciona:
                </p>

                <div class="code">
                  // Operador IN (->)
                  $result = $st->get('users')->filter('id', '->', array(1,2,3,4))->list();
                </div>

                <p>
                  No trecho de código abaixo demonstramos o mesmo exemplo acima só que
                  usando o método <code>in()</code>:
                </p>

                <div class="code">
                  $result = $st->get('users')->filter('id')->in(1, 2, 3, 4)->list();
                </div>

                <p>Os dois exemplos acima gera a mesma instrução SQL:</p>

                <div class="code">
                  SELECT * FROM users WHERE id IN (:col_1, :col_2, :col_3, :col_4)
                </div>

                <p>
                  Os métodos <code>in()</code> e <code>notIn()</code> recebem como parâmetro
                  tanto um array de dados quanto um conjunto de valores separados por vírgulas.
                </p>

                <p>
                  Lembrando que você pode também usar <code>Named Placeholders</code> tanto no método
                  <code>filter()</code> quanto nos métodos <code>in()</code> e <code>notIn()</code>:
                </p>

                <div class="code">
                  $result = $st->get('users')->filter('id', '!->', array(':id1', ':id2'))
                  ->list(array('id1' => 1, 'id2' => 2));
                </div>
              </section>

              <section>
                <h5 id="2.6.2.3">BETWEEN e NOT BETWEEN</h5>

                <p>
                  Os operadores <code>BETWEEN</code> e <code>NOT BETWEEN</code> podem ser adicionados a query
                  através do método <code>filter()</code> ou através dos métodos <code>between()</code>
                  e <code>notBetween()</code>.
                </p>

                <p>
                  Dentro do método <code>filter()</code> o operador <code>BETWEEN</code> corresponde ao sinal
                  <code>' | '</code>, enquanto o operador <code>NOT BETWEEN</code> corresponde ao sinal
                  <code>' ^| '</code>. Veja como funciona:
                </p>

                <div class="code">
                  // Usando operador BETWEEN |
                  $result = $st->get('articles')
                  ->filter('updated_at', '|', array('2022-01-01', '2022-02-01'))->list();
                </div>

                <p>
                  No código acima buscamos por todos os registros da tabela <code>articles</code>
                  que foram atualizados entre as datas <code>2022-01-01</code> a <code>2022-02-01</code>
                </p>

                <p>
                  Agora observe o mesmo exemplo acima só que desta vez usando o método <code>between()</code>:
                </p>

                <div class="code">
                  $result = $st->get('articles')
                  ->filter('updated_at')->between('2022-01-01', '2022-02-01')->list();
                </div>

                <p>
                  Tanto o método <code>filter()</code> quanto os métodos <code>between()</code> e 
                  <code>notBetween()</code> aceitam <code>Named Placeholders</code>.
                </p>

                <div class="code">
                  // Usando método filter
                  $result = $st->get('articles')
                  ->filter('updated_at', '|', array(':date1', ':date2'))
                  ->list(array('date1' => '2022-01-01', 'date2' => '2022-02-01'));

                  // Usando método notBetween
                  $result = $st->get('articles')
                  ->filter('updated_at')->between(':date1', ':date2')
                  ->list(array('date1' => '2022-01-01', 'date2' => '2022-02-01'));
                </div>
              </section>

              <section>
                <h5 id="2.6.2.4">LIKE</h5>

                <p>
                  DataB disponibiliza três métodos para se trabalhar com o operador <code>LIKE</code>:
                </p>

                <ul>
                  <li>
                    <code>DataB::startsWith()</code> - Busca por um valor que começa com um padrão.
                  </li>
                  <li>
                    <code>DataB::contains()</code> - Busca por um valor que contêm um padrão.
                  </li>
                  <li>
                    <code>DataB::endsWith()</code> - Busca por um valor que termina com um padrão.
                  </li>
                </ul>

                <p>
                  A seguir demonstramos o uso do método <code>DataB::startsWith()</code> para buscar somente
                  os registros da tabela <code>categories</code> onde o nome inicia com a letra <code>R</code>.
                  Observe:
                </p>

                <div class="code">
                  $categories = DataB::select('*')
                  ->table('categories')
                  ->cond('name')
                  ->startsWith('R')
                  ->exec()
                  ->getAll();
                </div>

                <p>
                  Veja o mesmo exemplo acima só que usando o método <code>DataB::exec()</code> para receber o
                  padrão como parâmetro:
                </p>

                <div class="code">
                  $categories = DataB::select('*')
                  ->table('categories')
                  ->cond('name')
                  ->startsWith('?')
                  ->exec(['R%'])
                  ->getAll();
                </div>

                <p>
                  No exemplo acima foi usado <code>mask placeholders</code>, mas você pode usar também
                  <code>named placeholders</code>.
                </p>
              </section>

              <section>
                <h5 id="2.6.2.5">IS NULL e IS NOT NULL</h5>

                <p>
                  Use os métodos <code>DataB::isNull()</code> e <code>DataB::isNotNull()</code>. No
                  exemplo abaixo fazemos uma consulta na tabela <code>books</code> buscando por todos
                  os registros onde a coluna <code>note</code> tenha valor nulo:
                </p>

                <div class="code">
                  $books = DataB::select('*')
                  ->table('books')
                  ->cond('note')
                  ->isNotNull()
                  ->exec()
                  ->getAll();
                </div>
              </section>

              <section>
                <h5 id="2.6.2.6">EXISTS e NOT EXISTS</h5>

                <p>
                  Geralmente o operador <code>EXISTS</code> é usado com subqueries. Não entraremos a fundo
                  neste conteúdo pois temos uma seção específica para abordá-lo. No entanto demonstraremos
                  como usá-lo.
                </p>

                <p>
                  DataB disponibiliza os métodos <code>DataB::exists()</code> e <code>DataB::notExists()</code>
                  os quais recebem como parâmetro uma função <code>callback</code>
                  que retorna uma subquery. Veja como funciona:
                </p>

                <div class="code">
                  $result = DataB::select('*')
                  ->table('authors')
                  ->exists(function() {
                  return DataB::select('*')
                  ->table('books')
                  ->cond('published')
                  ->between(2000, 2019)
                  ->and('authors.id')
                  ->eqColumn('books.authors_id');
                  })
                  ->exec()
                  ->getAll();
                </div>

                <p>
                  No trecho de código acima buscamos por todos os autores que tenham livros publicados entre os anos de
                  <code>2000</code> e <code>2019</code>.
                </p>

                <p>
                  Agora observe como fica a instrução SQL correspondente ao exemplo anterior:
                </p>

                <div class="code">
                  SELECT * FROM authors WHERE
                  EXISTS (SELECT * FROM books WHERE published BETWEEN ? AND ? AND authors.id = books.authors_id)
                </div>

              </section>

              <!--fim secao operadores logicos-->
            </section>

            <!--Fim secao filtrando dados-->
          </section>

          <section>
            <h3 id="2.7">Limitando retorno de linhas</h3>
            <p>
              Use <code>DataB::limit()</code>:
            </p>

            <div class="code">
              $books = DataB::select('*')
              ->table('books')
              ->limit(10)
              ->exec()
              ->getAll();
            </div>

            <p>
              Você pode especificar a partir de qual registro será retornado o resultado
              da consulta. Observe:
            </p>

            <div class="code">
              $books = DataB::select('*')
              ->table('books')
              ->limit(10, 2)
              ->exec()
              ->getAll();
            </div>

            <p>Abaixo ilustramos a instrução SQL equivalente ao trecho de código acima:</p>

            <div class="code">
              SELECT * FROM produtos LIMIT 2, 10
            </div>

            <p>
              No trecho de código acima, buscamos por dez registros da tabela <code>books</code>, inicando
              na linha seguinte depois da linha <code>2</code>.
            </p>
          </section>

          <section>
            <h3 id="2.8">Buscando dados não duplicados</h3>
            <p>Use o método <code>DataB::distinct()</code>:</p>

            <div class="code">
              // buscando registros que não tenham o ano de publicação duplicado
              $books = DataB::distinct('published')
              ->table('books')
              ->exec()
              ->getAll();
            </div>
          </section>

          <section>
            <h3 id="2.9"> Junção de tabelas</h3>
            <p>
              Nesta seção demonstramos como fazer junção de tabelas com DataB. No exemplo abaixo,
              usamos o método <code>DataB::cond()</code> para criar a junção entre
              as tabelas <code>authors</code> e <code>books</code>:
            </p>

            <div class="code">
              $result = DataB::select('*')
              ->table('authors', 'books')
              ->cond('authors.id')
              ->eqColumn('books.authors_id')
              ->exec()
              ->getAll();
            </div>

            <p>Veja como fica a instrução SQL equivalente ao trecho de código acima:</p>

            <div class="code">
              SELECT * FROM authors, books WHERE authors.id = books.authors_id
            </div>

            <p>
              Agora, no exemplo abaixo, fazemos a junção de tabelas usando <code>inner join</code>:
            </p>

            <div class="code">
              $result = DataB::select('*')
              ->table('authors')
              ->innerJoin('books')
              ->on('authors.id')
              ->eqColumn('books.authors_id')
              ->exec()
              ->getAll();
            </div>

            <p>
              Ok. Os demais métodos disponíveis em DataB para criar junções de tabelas são estes:
              <code>DataB::leftJoin()</code>, <code>DataB::rightJoin()</code> e <code>DataB::crossJoin()</code>.
            </p>

            <p>
              <strong>Observação:</strong> Se os campos de comparação das tabelas envolvidas tiverem o mesmo nome, então
              você pode usar o método <code>DataB::using()</code> em vez do método <code>DataB::on()</code>. Veja como
              funciona:
            </p>


            <div class="code">
              $result = DataB::select('*')
              ->table('authors')
              ->innerJoin('books')
              ->using('author_id')
              ->exec()
              ->getAll();
            </div>

            <p>
              Para que o método <code>DataB::using()</code> funcione corretamente, o nome do campo que
              representa a chave primária na primeira tabela deverá ser idêntico ao nome do campo de referência
              na segunda tabela.
            </p>
            <!--Fim secao junção de tabelas-->
          </section>

          <section>
            <h3 id="2.10">Agrupando dados</h3>

            <p>
              Para agrupar dados use os métodos <code>DataB::groupBy()</code>; e para definir condições
              para o agrupamento de dados use o método <code>DataB::having()</code>. Observe
              no exemplo abaixo no qual contamos quantos livros existem por categoria:
            </p>

            <div class="code">
              $result = DataB::select('categories.name')
              ->alias('Categoria')
              ->count('*')
              ->alias('Qtd livros')
              ->table('categories', 'books')
              ->cond('categories.id')
              ->eqColumn('books.categories_id')
              ->groupBy('categories.id')
              ->exec()
              ->getAll();
            </div>

            <p>
              Veja como fica a instrução SQL equivale ao exemplo anterior:
            </p>

            <div class="code">
              array (size=3)
              0 =>
              array (size=2)
              'Categoria' => string 'Romance' (length=7)
              'Qtd livros' => string '3' (length=1)
              1 =>
              array (size=2)
              'Categoria' => string 'Drama' (length=5)
              'Qtd livros' => string '3' (length=1)
              2 =>
              array (size=2)
              'Categoria' => string 'Autobiografia' (length=13)
              'Qtd livros' => string '1' (length=1)
            </div>

            <p>
              Se você já está familiarizado com o uso do método <code>DataB::cond()</code> então não terá
              nenhum problema ao usar o método <code>Data::having()</code> pois funcionam da mesma maneira.
            </p>
          </section>

          <section>
            <h3 id="2.11">Union</h3>

            <p>
              Para unir dois ou mais conjuntos de resultados DataB disponibiliza os seguintes métodos:
              <code>DataB::union()</code>, <code>DataB::unionAll()</code> e <code>DataB::unionDistinct()</code>.
            </p>

            <p>
              Todos esses métodos recebem como parâmetro uma <code>função callback</code> que retorna uma
              <code>subquery</code>. Observe no exemplo a seguir:
            </p>

            <div class="code">
              $result = DataB::select('books.title')
              ->table('books')
              ->union(function() {
              return DataB::select('authors.name')
              ->table('authors');
              })
              ->exec()
              ->getAll();
            </div>
          </section>

          <section>
            <h3 id="2.12">Subqueries</h3>

            <p>
              No ambiente de banco de dados é bastante comum o uso de subqueries para construir
              consultas SQL complexas. Pois bem, DataB fornece
              suporte a subqueries no qual usamos funções callbacks para criá-las. A maioria dos métodos em DataB
              recebem
              função callback como parâmetro tanto para se criar subqueries quanto subexpressões. A seguir
              disponibilizamos
              uma lista com todos os método que suportam subqueries:
            </p>

            <ul>
              <li>
                <code>DataB::eqValue()</code>
              </li>
              <li>
                <code>DataB::neValue()</code>
              </li>
              <li>
                <code>DataB::ltValue()</code>
              </li>
              <li>
                <code>DataB::gtValue()</code>
              </li>
              <li>
                <code>DataB::leValue()</code>
              </li>
              <li>
                <code>DataB::geValue()</code>
              </li>
              <li>
                <code>DataB::in()</code>
              </li>
              <li>
                <code>DataB::notIn()</code>
              </li>
              <li>
                <code>DataB::exists()</code>
              </li>
              <li>
                <code>DataB::notExists()</code>
              </li>
              <li>
                <code>DataB::union()</code>
              </li>
              <li>
                <code>DataB::unionAll()</code>
              </li>
              <li>
                <code>DataB::unionDistinct()</code>
              </li>
              <li>
                <code>DataB::values()</code>
              </li>
              <li>
                <code>DataB::set()</code>
              </li>
            </ul>

            <p>
              A função callback passada por parâmetro deve retornar um objeto <code>DataB</code> que representa
              a query SQL.
            </p>

            <p>
              Observe no exemplo a seguir no qual buscamos todos os registros da tabela <code>books</code>
              somente se existir algum registro cadastrado na tabela <code>authors</code>:
            </p>

            <div class="code">
              $result = DataB::select('*')
              ->table('books')
              ->exists(function() {
              return DataB::select('*')->table('authors');
              })
              ->exec()
              ->getAll();
            </div>

            <p>
              Neste outro exemplo buscamos somente os registros da tabela <code>books</code> onde
              o nome da categoria começa com a letra <code>R</code>. Observe também que dentro da subquery
              usamos <code>mask placeholders</code> como entrada de parâmetro para o método
              <code>DataB::startsWith()</code>
              em vez de passar o valor literal. Fica a seu critério usar <code>mask placeholder</code>,
              <code>named placeholders</code> ou o próprio valor literal:
            </p>

            <div class="code">
              $result = DataB::select('*')
              ->table('books')
              ->cond('categories_id')
              ->eqValue(function() {
              return DataB::select('id')
              ->table('categories')
              ->cond('name')
              ->startsWith('?');
              })
              ->exec(['R%'])
              ->getAll();
            </div>

            <p>
              O código SQL correspondente ao exemplo acima é ilustrado a seguir:
            </p>

            <div class="code">
              SELECT * FROM books
              WHERE categories_id = (SELECT id FROM categories WHERE name LIKE ?)
            </div>
          </section>

          <section>
            <h3 id="2.13">Subexpressões</h3>
            <p>
              Subexpressões são criadas passando uma função callback como parâmetro para os métodos
              <code>DataB::and()</code> e <code>DataB::or()</code>. Observe:
            </p>

            <div class="code">
              $result = DataB::select('*')
              ->table('books')
              ->cond('categories_id')
              ->eqValue(1) // Romance
              ->and(function() {
              return DataB::column('published')
              ->eqValue(2019)
              ->or('price')
              ->leValue(40.00);
              })
              ->exec()
              ->getAll();
            </div>

            <p>
              Observe que passamos uma função callback para o método <code>DataB::and()</code>. Dentro dessa função
              criamos e retornamos a subexpressão.
            </p>

            <p>
              Veja como fica a instrução SQL referente ao exemplo anterior:
            </p>

            <div class="code">
              SELECT * FROM books
              WHERE categories_id = ?
              AND (published = ? OR price &lt;= ?)
            </div>
          </section>
          <!--Fim secao consultas-->
        </section>

        <section>
          <h1>Modificando dados</h1>

          <p>
            Nesta seção você aprenderá como inserir, atualizar e remover registros do banco de dados
            usando <code>DataB</code>.
          </p>

          <section>
            <h3 id="3.1">Inserindo registros</h3>

            <p>
              Para inserir novos registros em uma tabela com DataB muito fácil, basta passar
              para o método <code>DataB::insert()</code> a relação de campos da tabela que
              você quer inserir. Essa relação pode ser tanto um <code>array</code> quanto uma lista
              de <code>strings</code>.
            </p>

            <p>
              Veja no exemplo abaixo no qual inserimos um registro na tabela <code>books</code>:
            </p>

            <div class="code">
              $id = DataB::insert('title', 'price', 'published', 'categories_id', 'authors_id')
              ->table('books')
              ->values('Cinquenta Tons de Cinza', 24.95, 2011, 1, 1)
              ->exec()
              ->getLastInsertedId();
            </div>

            <p>
              Agora observe o mesmo exemplo só que passando um array como parâmetro para o método
              <code>DataB::insert()</code>:
            </p>

            <div class="code">
              $columns = ['title', 'price', 'published', 'categories_id', 'authors_id'];

              $id = DataB::insert($columns)
              ->table('books')
              ->values('Cinquenta Tons de Cinza', 24.95, 2011, 1, 1)
              ->exec()
              ->getLastInsertedId();
            </div>

            <p>
              No exemplos acima passamos os valores literais para o método <code>DataB::values()</code>, mas
              você pode usar também <code>mask placeholders</code> ou <code>named placeholders</code>.
            </p>

            <p>
              Usando mask placeholders:
            </p>

            <div class="code">
              $data = ['Cinquenta Tons de Cinza', 24.95, 2011, 1, 1];

              $id = DataB::insert('title', 'price', 'published', 'categories_id', 'authors_id')
              ->table('books')
              ->values('?', '?', '?', '?', '?')
              ->exec($data)
              ->getLastInsertedId();
            </div>

            <p>
              Usando named placeholders:
            </p>

            <div class="code">
              $data = [
              'title' => 'Cinquenta Tons de Cinza',
              'price' => 24.95,
              'published' => 2011,
              'cat_id' => 1,
              'authors_id' => 1
              ];

              $id = DataB::insert('title', 'price', 'published', 'categories_id', 'authors_id')
              ->table('books')
              ->values(':title', ':price', ':published', ':cat_id', ':authors_id')
              ->exec($data)
              ->getLastInsertedId();
            </div>

            <p>
              No exemplo abaixo mostramos como inserir vários registros ao mesmo tempo:</code>
            </p>

            <div class="code">
              $id = DataB::insert('name')
              ->table('authors')
              ->values('Carlos Coutinho')
              ->values('Junior César')
              ->values('Cláudio Borges')
              ->exec()
              ->getLastInsertedId();
            </div>

            <p>
              Você pode também inserir um novo registro usando dados de uma consulta. Neste caso, devemos passar
              para o método <code>Datab::values()</code> uma função callback que retorna uma subquery.
              Observe:
            </p>

            <div class="code">
              $id = DataB::insert('name')
              ->table('authors')
              ->values(function() {
              return DataB::select('name')
              ->table('authors')
              ->cond('id')
              ->eqValue(2);
              })
              ->exec()
              ->getLastInsertedId();
            </div>

            <p>
              No exemplo acima buscamos pelo registro da tabela <code>authors</code> cujo campo identificador
              <code>(id)</code> seja igual a <code>2</code>, entao usamos o resultado dessa query para inserir um novo
              registro no banco de dados
            </p>

            <p>
              Se você não especificar um filtro para limitar a quantidade de registros retornados pela query então todos
              os registros retornados serao inseridos no banco de dados.
            </p>
          </section>

          <section>
            <h3 id="3.2">Atualizando registros</h3>

            <p>
              Para fazer atualizações de registros em uma tabela específca devemos usar o método
              <code>DataB::update()</code> no qual passampos por parâmetro a lista de colunas que
              queremos atualizar; em seguida usamos o método <code>DataB::table()</code> para
              definirmos em qual tabela ocorrerá as alterações; na sequência invocamos o método
              <code>DataB::set()</code> no qual informamaos um conjunto de dados correspondentes à
              lista de campos que queremos atualizar.
            </p>

            <p>
              No trecho de código abaixo atualizamos o registro da tabela <code>books</code>
              onde o campo identificador <code>id</code> seja igual a <code>1</code>:
            </p>

            <div class="code">
              $rowCount = DataB::update('price', 'note')
              ->table('books')
              ->set(65.98, 'Este livro foi atualizado')
              ->cond('id')
              ->eqValue(1)
              ->exec()
              ->rows();
            </div>

            <p>
              O método <code>DataB::rows()</code> retorna o número de linhas afetadas pela query.
            </p>

            <p>
              No exemplo acima passamos como parâmetro para o método <code>DataB::set()</code> os valores
              literais, mas você pode usar também <code>mask placeholders</code> ou <code>named placeholders</code>.
            </p>

            <p>
              No exemplo abaixo demonstramos o mesmo exemplo só que usando <code>mask placeholders</code> e
              passando a lista de campos para o método <code>DataB::update()</code> como um array:
            </p>

            <div class="code">
              $rowCount = DataB::update(['price', 'note'])
              ->table('books')
              ->set('?', '?')
              ->cond('id')
              ->eqValue('?')
              ->exec([68.98, 'Este livro foi atualizado', 1])
              ->rows();
            </div>

            <p>
              Neste outro exemplo demonstramos o uso de <code>named placeholders</code>:
            </p>

            <div class="code">
              $rowCount = DataB::update(['price', 'note'])
              ->table('books')
              ->set(':price', ':note')
              ->cond('id')
              ->eqValue(':id')
              ->exec([
              'price' => 68.98,
              'note' => 'Este livro foi atualizado',
              'id' => 1])
              ->rows();
            </div>

            <p>
              Agora vamos mostrar como atualizar coluna usando o resultado de uma <code>subquery</code>:
            </p>

            <div class="code">
              $rowCount = DataB::update('price', 'note')
              ->table('books')
              ->set(64.95,
              function() {
              return DataB::select('name')
              ->table('authors')
              ->cond('id')
              ->eqValue(1);
              }
              )
              ->cond('id')
              ->eqValue(2)
              ->exec()
              ->rows();
            </div>

            <p>
              No exemplo acima atualizamos o valor da coluna <code>price</code> para <code>64.95</code>
              e para a coluna <code>note</code> definimos como valor o resultado da subquery que retorna
              o nome do autor cujo campo identificador tenha valor igual a <code>1</code>. Essa atualização
              será feita somente no registro onde o campo identificar tenha valor igual a <code>2</code>.
            </p>

            <p>
              Veja como fica o código SQL equivalente ao exemplo anterior:
            </p>

            <div class="code">
              UPDATE books
              SET price = ?,
              note = (SELECT name FROM authors WHERE id = ?)
              WHERE id = ?
            </div>
          </section>

          <section>
            <h3 id="3.3">Removendo registros</h3>

            <p>O processo de remover registros de uma tabela é muito simples. Veja como funciona:</p>

            <div class="code">
              $rowCount = DataB::delete('books')
              ->exec()
              ->rows();
            </div>

            <p>
              No trecho de cógido acima excluímos todos os registros da tabela <code>books</code>.
              Para definirmos filtros par alimitar quais registros deverão ser excluídos você pode usar
              o método <code>DataB::cond()</code> para encaderar os filtros. Observe:
            </p>

            <div class="code">
              $rowCount = DataB::delete('books')
              ->cond('id')
              ->eqValue(2)
              ->exec()
              ->rows();
            </div>
          </section>

          <section>
            <h3 id="3.4">Usando transações</h3>

            <p>
              Para alterar, atualiazar ou remover registros de forma segura use o método
              <code>DataB::transaction()</code>
              que recebe como parâmetro uma função callback que executa uma instrução SQL dentro de uma transação
              de banco de dados. Caso ocorra uma falha na transação SQL então tudo será desfeito (rollback).
            </p>

            <div class="code">
              $id = DataB::transaction(function() {
              return DataB::insert('name')
              ->table('categories')
              ->values('Tecnologia')
              ->exec()
              ->getLastInsertedId();
              });
            </div>

            <p>
              O métod <code>DataB::transaction()</code> só retorna um valor se você retornar o valor do callback.
            </p>
          </section>

          <!--Fim secao modificando dados-->
        </section>

        <hr>

      </div>
    </div>
  </main>

  <script>
    document.querySelectorAll('div.code').forEach(el => {
      hljs.highlightElement(el);
    });
    function toggleSidebar() {
      document.querySelector('#sidebarElem').classList.toggle('hide');
      document.querySelector('#contentElem').classList.toggle('hide');
    }
  </script>
  <!--
  <script src="https://code.jquery.com/jquery-3.6.0.slim.min.js"
    integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
  -->

  <script>window.jQuery || document.write('<script src="./js/jquery.js"><\/script>')</script>

  <!-- JavaScript Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
    crossorigin="anonymous"></script>

  <script src="./js/main.js"></script>
</body>

</html>