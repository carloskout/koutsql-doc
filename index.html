<!doctype html>
<html lang="pt-br">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Documentação DataB">
  <meta name="author" content="Carlos Coutinho">
  <title>Documentação DataB</title>


  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.1/font/bootstrap-icons.css">

  <link rel="stylesheet" href="./css/idea.min.css">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="./css/style.css">

  <script src="./js/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>

  <div id="header-container">
    <header class="container-fluid bg-primary" id="header-top">
      <div>
        <a id="logo" href="#">
          DataB<i class="bi bi-server"></i>
        </a>
      </div>

      <div>
        <a href="#" id="link-github">
          DataB no Github
          <i class="bi bi-box-arrow-up-right"></i>
        </a>
      </div>
    </header>
  </div>

  <!--Siderbar-->
  <button class="btn-bar">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>

  <aside class="sidebar">
    <div class="sidebar-header">
      <h3>Conteúdo</h3>
    </div>
    <hr>
    <nav>
      <ul>
        <li>
          <details>
            <summary>
              <a href="#1">1. Introdução</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#1.1">1.1. Detalhes</a>
              </li>
              <li>
                <a href="#1.2">1.2. Como instalar</a>
              </li>
              <li>
                <a href="#1.3">1.3. Configuração e exemplo de uso</a>
              </li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary>
              <a href="#2">2. Consultas SQL</a>
            </summary>
            <ul class="sublist">
              <li>
                <a href="#2.1">2.1. Recuperando resultado</a>
              </li>
              <li>
                <a href="#2.2">2.2. Consultas nativas</a>
              </li>
              <li>
                <a href="#2.3">2.3. Funções de agregação</a>
              </li>
              <li>
                <a href="#2.4">2.4. Funções nativas</a>
              </li>
              <li>
                <a href="#2.5">2.5. Ordenação de dados</a>
              </li>
              <li>
                <details>
                  <summary>
                    <a href="#2.6">2.6. Filtrando dados</a>
                  </summary>
                  <ul class="sublist">
                    <li>
                      <a href="#2.6.1">2.5. Operadores relacionais</a>
                    </li>
                  </ul>
                </details>
              </li>
            </ul>
          </details>
        </li>
      </ul>
    </nav>
  </aside>

<main class="content">
<div class="row">
<div class="col-md-9">

<section>
  <h1 id="1">Introdução</h1>
  <p>
    DataB é uma library PHP que facilita a criação e execução de instruções SQL usando PDO (PHP Data Object).
  </p>

  <section>
    <h3 id="1.1">Detalhes</h3>
    <p>
      Bancos de dados suportados: <b>MYSQL</b> <br>
      Versão atual: <b>1.0.1</b> <br>
      Licença: <b>MIT</b>
    </p>
  </section>

  <section>
    <h3 id="1.2">Como instalar</h3>
    <p>
      DataB pode ser instalada através do Composer, que é gerenciador de pacotes
      para a linguagem PHP. Basta executar o comando: <code>composer require kout/datab</code>
    </p>
    <p>
      Instalado? Ótimo! Agora você está pronto para dá os primeiros passos
      com DataB através de exemplos práticos</a>.
    </p>
  </section>

  <section>
    <h3 id="1.3">Configuração e exemplo de uso</h3>
    <p>
      Antes de comerçar a criar e executar instruções SQL, primeiro você deve
      informar para DataB uma conexão com Banco de Dados existente. Para isso, basta
      passar por parâmetro um objeto PDO para o método <code>DataB::setPDO</code>:
    </p>
  </section>

<pre>
<code>
$pdo = new \PDO(...);
DataB::setPDO($pdo);
</code>
</pre>

  <p>Prontinho! Agora você já pode começar a criar e executar instruções SQL. Veja como é fácil:</p>

<pre>
<code>
$result = DataB::select('*')
->table('books')
->exec()
->getAll();
</code>
</pre>

  <p>
    No exemplo acima, buscamos por todos os registros da tabela <code>books</code>.
  </p>

  <p>
    Para ver a instrução SQL gerada no código acima, basta executar o método <code>sql()</code> em vez do
    método <code>exec()</code>:
  </p>

<pre>
<code>
$sql = DataB::select('*')
->table('books')
->sql();

var_dump($sql);
</code>
</pre>
</section>

<hr>

<section>
  <h1 id="2">Consultas SQL</h1>
  <p>
    Para fazer consultas SQL use o método <code>select()</code> para especificar a lista de campos que serão
    retornados pela consulta. Você pode passar por parâmetro tanto um array de
    nomes de colunas quanto uma lista de nomes de colunas separadas por virgulas. Em seguida, use o
    método <code>table()</code> para definir em qual tabela será feita a consulta de dados.
</p>
<p>
    No exemplo abaixo passamos um array como parâmetro contendo os nomes das colunas que queremos recuperar no resultado da query:
</p>

<pre>
<code>
$columns = array(
'title',
'price',
'published'
);

$books = DataB::select($columns)
->table('books')
->exec()
->getAll();

var_dump($books);
</code>
</pre>

<p>
  Neste outro exemplo passamos duas strings por parâmetro representando os nomes das colunas que queremos recuperar no resultado da query:
</p>

<pre>
<code>
$books = DataB::select('title', 'published')
->table('books')
->exec()
->getAll();

var_dump($books);
</code>
</pre>

<p>
    O método <code>exec()</code> é chamado para executar a instrução SQL enquanto o método
    <code>getAll()</code> recupera o resultado retornado pelo o banco de dados.
</p>
<p>Para recuperar todos os campos da tabela use <code>select('*')</code></p>

<section>
  <h3 id="2.1">Recuperando resultado</h3>
  <p>
    Use <code>getAll()</code> para recuperar todos
    os registros retornados pela consulta:
</p>

<pre>
<code>
$authors = DataB::select('*')
->table('authors')
->exec()
->getAll();

var_dump($authors);
</code>
</pre>

<p>
    O código acima gera a seguinte saída:
</p>

<pre>
<code>
array (size=5)
0 => 
array (size=2)
'id' => string '1' (length=1)
'name' => string 'Yvonne do Amaral Pereira' (length=24)
1 => 
array (size=2)
'id' => string '2' (length=1)
'name' => string 'Henrik Ibsen' (length=12)
2 => 
array (size=2)
'id' => string '3' (length=1)
'name' => string 'John Green' (length=10)
...
</code>
</pre>

<p>
    Use <code>getFirst()</code> para recuperar o primeiro
    registro retornado pela consulta:
</p>

<pre>
<code>
$category = DataB::select('*')
->table('categories')
->exec()
->getFirst();

var_dump($category);
</code>
</pre>

<p>
    Use <code>getLast()</code> para recuperar o último
    registro retornado pela consulta:
</p>

<pre>
<code>
$author = DataB::select('*')
->table('categories')
->exec()
->getLast();

var_dump($category);
</code>
</pre>

<p>
    Use <code>getSingleResult()</code> para recuperar o valor literal retornado pela query.
    Observe que, diferente dos outros métodos visto acima, este método não retorna um array contento o resultado da
    consulta: Observe o trecho de código abaixo:
</p>

<pre>
<code>
$result = DataB::select(1 + 1)
->exec()
->getSingleResult();

var_dump($result);

// A saída do método var_dump() será o valor '2'

</code>
</pre>

<p>
    Veja este outro exemplo onde buscamos pelo campo <code>title</code> da tabela
    <code>books</code>. Neste exemplo, usamos uma condição para limitar a quantidade de registros retornados pela
    query. Se nenhuma condição for definida, então o método <code>getSingleResult()</code>
    retornará o valor da primeira coluna do primeiro registro encontrado.
</p>

<pre>
<code>
$title = DataB::select('title')
->table('books')
->cond('id')
->eqValue(1)
->exec()
->getSingleResult();

var_dump($title);
</code>
</pre>

<p>
    Use <code>getObjects()</code> para recuperar todos os
    registros como objetos. Este método recebe por
    parâmetro o nome da classe que será usada para criar as instâncias dos objetos.
    Se nenhum parâmetro for especificado, então os registros serão retornados como
    objetos 'stdClass':
</p>

<pre>
<code>

class Author {

}

$authors = DataB::select('*')
->table('authors')
->exec()
->getObjects('Author');

var_dump($authors);
</code>
</pre>

<p>
    O código acima gera a seguinte saída:
</p>

<pre>
<code>
array (size=5)
0 => 
object(Author)[2]
public 'id' => string '1' (length=1)
public 'name' => string 'Yvonne do Amaral Pereira' (length=24)
1 => 
object(Author)[6]
public 'id' => string '2' (length=1)
public 'name' => string 'Henrik Ibsen' (length=12)
...
</code>
</pre>

<p>
    Use <code>getObject()</code> para recuperar o primeiro
    registro como objeto. Este método recebe como
    parâmetro o nome da classe que será usada para criar a instância do objeto.
    Se nenhum parâmetro for especificado, então o primeiro registro será retornado como
    um objeto 'stdClass'.
</p>

<p>
    Use <code>getLazy()</code> para recuperar o primeiro
    registro como um objeto PDORow onde as variáveis desse objeto correspondem
    aos nomes das colunas da tabela. Esse método faz o carregamento dos
    dados conforme as variáveis do objeto <code>PDORow</code> forem acessadas.
</p>

</section>

<section>
  <h3 id="2.2">Consultas nativas</h3>
  <p>
    Para executar consultas nativas use <code>DataB::nativeSQL()</code>.
    Este método executa qualquer instrução SQL, tanto
    DML quanto DDL.
  </p>

  <p>Executando instrução DML:</p>

<pre>
<code>
$sql = 'SELECT * FROM authors';
$authors = DataB::nativeSQL($sql)->getAll();
</code>
</pre>

  <p>Executando instrução DDL:</p>

<pre>
<code>
$sql = 'ALTER TABLE categories ADD COLUMN parent INTEGER';
$rowCount = DataB::nativeSQL($sql)->rows();
</code>
</pre>
</section>

<section>
  <h3 id="2.3">Funções de agregação</h3>

  <p>
    As funções de agregação em DataB podem ser acessadas de forma
    estática ou através de referências de objetos. Lembre-se, caso queira
    acessar por referência você deve chamar a funcão na orderm correta, ou seja,
    logo após a chamada do método <code>DataB::select()</code>.
  </p>

  <p>
      Veja no exemplo a seguir onde contamos quantos registros existem na
      tabela <code>categories</code>:
  </p> 

<pre>
<code>
$count = DataB::count('*')
->table('categories')
->exec()
->getSingleResult();
</code>
</pre>

<p>
    Neste outro exemplo contamos quantos livros foram publicados por 
    cada autor:
</p>

<pre>
<code>
$result = DataB::select('authors.name')
->count('*')
->alias('qtd_livros_publicados')
->table('books')
->innerJoin('authors')
->on('books.authors_id')
->eqColumn('authors.id')
->groupBy('authors.name')
->exec()
->getAll();
</code>
</pre>

<p>Saída SQL:</p>

<pre>
<code>
SELECT authors.name, COUNT(*) AS 'qtd_livros_publicados' FROM books
INNER JOIN authors ON books.authors_id = authors.id 
GROUP BY authors.name
</code>
</pre>

  <p>As demais funções de agregação implementadas em DataB são listadas abaixo:</p>
  
  <ul>
      <li>
          <code>DataB::min()</code> - Busca pelo menor valor dentre um conjuntos de valores.
      </li>
      <li>
          <code>DataB::max()</code> - Busca pelo maior valor dentre um conjuntos de valores.
      </li>
      <li>
          <code>DataB::avg()</code> - Busca pela média aritmética dentre um conjuntos de valores.
      </li>
      <li>
          <code>DataB::sum()</code> - Busca pela soma total dentre um conjuntos de valores.
      </li>
  </ul>
</section>

<section>
  <h3 id="2.4">Funções nativas</h3>

  <p>
    Você pode executar qualquer função nativa do banco de dados fazendo
    chamada ao nome da função precedida pelo prefixo (fn). A chamada pode ser tanto
    de forma estática quanto por referência. Lembre-se, caso queira
    acessar por referência você deve chamar a funcão na orderm correta, ou seja,
    logo após a chamada do método <code>DataB::select()</code>.
  </p>

  <p>
    No exemplo abaixo fazemos uma chamada estática à funcão nativa <code>concat</code> onde
    mesclamos os títulos e os preços de cada livro armazenado na tabela <code>books</code>:
  </p>
<pre>
<code>
$result = DataB::fnConcat('title', "' | R$ '", 'price')
->alias('Título com Preço')
->table('books')
->exec()
->getAll();

var_dump($result);
</code>
</pre>

<p>Saída <code>var_dump()</code>:</p>
<pre>
<code>
array (size=7)
0 => 
array (size=1)
'Título com Preço' => string 'Memórias de um suicida | R$ 52.80' (length=34)
1 => 
array (size=1)
'Título com Preço' => string 'Nas voragens do pecado | R$ 35.95' (length=33)
...
</code>
</pre>

<p>
Neste outro exemplo executamos a mesma função só que fazendo chamada
por referência:
</p>

<pre>
<code>
$result = DataB::select('title')
->fnConcat('published', "' | '", 'price')
->alias('Ano pub. com Preço')
->table('books')
->exec()
->getAll();
</code>
</pre>

<p>Saída <code>var_dump()</code>:</p>

<pre>
<code>
array (size=7)
0 => 
array (size=2)
'title' => string 'Memórias de um suicida' (length=23)
'Ano pub. com Preço' => string '1958 | 52.80' (length=12)
1 => 
array (size=2)
'title' => string 'Nas voragens do pecado' (length=22)
'Ano pub. com Preço' => string '1959 | 35.95' (length=12)
...
</code>
</pre>
<p>
Se a função chamada não existir no banco de dados, uma exceção <code>DataBException</code>
será lançada.
</p>
</section>

<section>
  <h3 id="2.5">Ordenação de dados</h3>
  <p>
    Para ordenar dados use os métodos <code>orderByAsc()</code> e
    <code>orderByDesc()</code>. Esses métodos recebem como parâmetro
    a(s) coluna(s) que serão usadas na ordenação dos dados.
    Observe os exemplos a seguir:
</p>

<p>Ordenação ascendente:</p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->orderByAsc('published')
  ->exec()
  ->getAll();
</code>
</pre>

<p>Ordenação descendente:</p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->orderByDesc('published')
  ->exec()
  ->getAll();
</code>
</pre>

<p>Usando mais de uma coluna para ordenar dados:</p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->orderByAsc('title', 'published')
  ->exec()
  ->getAll();
</code>
</pre>
</section>

<section>
  <h3 id="2.6">Filtrando Dados</h3>

  <p>
    Para adicionar restrições à consulta SQL, você deve inicialmente usar o método 
    <code>DataB::cond()</code> que equivale à cláusula <code>WHERE</code>. Após a chamada
    desse método você pode encadear outros métodos para adicionar mais restrições à query.
  </p>

  <p>
    Observe no trecho de código abaixo, onde buscamos por todos os registros da tabela
    <code>books</code> onde o preço tem que ser igual a <code>29.99</code>:
  </p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->cond('price')
  ->eqValue(29.99)
  ->exec()
  ->getAll();
</code>
</pre>

<p>Abaixo ilustramos a intrução SQL equivalente ao trecho de código acima:</p>

<pre>
<code>
SELECT * FROM books WHERE price = ?
</code>
</pre>

<p>
  Observe a instrução SQL gerada no exemplo acima onde temos o campo
  <code>price = ?</code>. Por padrão, todos os parâmetros de entrada
  para a instrução SQL são convertidos para <strong>mask placeholders</strong> para evitar
  SQL Injection.
</p>

<p>
  Existem duas maneiras para criar parâmetros SQL com dados de entrada usando DataB.
  A primeira é através de métodos que recebem algum valor de entrada, como por exemplo o
  método <code>eqValue()</code> que equivale ao operador relacional de igualdade. A segunda é
  passando um array de dados para o método <code>exec()</code>. Ao trabalhar desta forma,
  fica ao seu critério usar <strong>mask placeholders</strong> ou <strong>named placeholders</strong>.
  Se você optar por esta, deverá passar um array associativo onde as chaves do array devem
  corresponder aos nomes das colunas da tabela; caso opte por aquela, então você terá que
  passar um array indexado como parâmentro. Veja como funciona:
</p>

<p>Usando <code>mask placeholders</code> :</p>

<pre>
<code>
$data = array('Romance');

$category = DataB::select('*')
  ->table('categories')
  ->cond('name')
  ->eqValue('?')
  ->exec($data)
  ->getAll();
</code>
</pre>

<p>Abaixo ilustramos a intrução SQL equivalente ao trecho de código acima:</p>

<pre>
<code>
SELECT * FROM categories WHERE name = ?
</code>
</pre>

<p>Usando <code>named placeholders</code>:</p>

<pre>
<code>

$data = array(
  'price' => 29.99,
  'published' => 2011
);

$book = DataB::select('*')
  ->table('books')
  ->cond('price')
  ->eqValue(':price')
  ->and('published')
  ->eqValue(':published')
  ->exec($data)
  ->getAll();
</code>
</pre>

<p>Abaixo ilustramos a intrução SQL equivalente ao trecho de código acima:</p>

<pre>
<code>
SELECT * FROM books WHERE price = :price
    AND published = :published'
</code>
</pre>

<section>
  <h4 id="2.6.1">Operadores relacionais</h4>

  <p>
    DataB disponibiliza métodos para comparação de valores literais, como strings, números, booleanos; e
    para comparação de colunas do banco de dados. Por exemplo, para usar o operador relacional de igualdade
    <code>(=)</code> para comparar valores literais use o método <code>DataB::eqValue()</code>; para comparar colunas do banco
    de dados use o método <code>DataB::eqColumn()</code>.
  </p>

  <p>
    Veja no exemplo abaixo no qual buscamos todos os registros da tabela <code>books</code> onde o
    ano de publicação seja igual a 2019:
  </p>

<pre>
<code>
$books = DataB::select('*')
  ->table('books')
  ->cond('published')
  ->eqValue(2019)
  ->exec()
  ->getAll();

var_dump($books);
</code>
</pre>

  <p>
    Neste outro exemplo fazemos consultas na tabela <code>authors</code> e <code>books</code> onde buscamos pelos nomes dos autores e pelos titulos de seus respectivos livros publicados:
  </p>

<pre>
<code>
$result = DataB::select('authors.name', 'books.title')
  ->table('authors, books')
  ->cond('authors.id')
  ->eqColumn('books.authors_id')
  ->exec()
  ->getAll();

var_dump($result);
</code>
</pre>

  <p>
    Veja a lista completa de todos os métodos usados para comparar valores com DataB:
  </p>

  <ul>
    <li>
        <code>eqValue()</code>, <code>eqColumn()</code> (=)
    </li>
    <li>
        <code>neValue()</code>, <code>neColumn()</code> (!=)
    </li>
    <li>
        <code>ltValue()</code>, <code>ltColumn()</code> (&lt;)
    </li>
    <li>
        <code>gtValue()</code>, <code>gtColumn()</code> (&gt;)
    </li>
    <li>
        <code>leValue()</code>, <code>leColumn()</code> (&lt;=)
    </li>
    <li>
        <code>geValue()</code>, <code>geColumn()</code> (&gt;=)
    </li>
</ul>

  <div class="alert alert-warning">
      <b>Observação:</b> Todo parâmetro de entrada para os métodos que comparam valores literais são convertidos
      para mask place holders por padrão para evitar SQL Injection. Você tem que tomar cuidado somente ao usar os métodos que comparam colunas do banco de dados, pois os parâmetros passados para esses métodos são usados diretamente na montagem da query.
  </div>

</section>

</section>

<!--Fim secao consultas-->
</section>

<hr>

</div>
</div>
</main>

  <!--
  <script src="https://code.jquery.com/jquery-3.6.0.slim.min.js"
    integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
  -->

  <script>window.jQuery || document.write('<script src="./js/jquery.js"><\/script>')</script>

  <!-- JavaScript Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
    crossorigin="anonymous"></script>

  <script src="./js/main.js"></script>
</body>

</html>